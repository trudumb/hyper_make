Priority-Based Queue-Aware Reconciliation
Goal
Replace the current greedy matching algorithm with a priority-based queue-aware system that:

Ensures best bid/ask are always populated first (priority matching)
Uses stochastic optimal spread to dynamically set matching thresholds
Preserves queue position for orders with high fill probability
Distributes orders across effective range (no artificial 5-order limit)
Exchange Constraints (User Confirmed)
Max Open Orders: 1000 limit orders across all assets
Min Notional: $10 per order
No Artificial Limit: Remove hardcoded 5-order limit, distribute across effective range
Proposed Changes
Component 1: Reconciliation Engine
[MODIFY] 
reconcile.rs
New: Priority-Based Matching Algorithm

Replace 
find_best_matches()
 with priority_based_matching():

/// Priority-based matching: ensure best levels are covered first.
/// 
/// Algorithm:
/// 1. Sort targets by priority (best price first for each side)
/// 2. For each target level in priority order:
///    a. Check if any existing order is within dynamic threshold
///    b. If yes and queue position is valuable → KEEP (no action)
///    c. If yes but queue is poor → REFRESH candidate
///    d. If no → PLACE new order (critical coverage gap)
/// 3. Orders not matched to any target → CANCEL
fn priority_based_matching<'a>(
    orders: &[&'a TrackedOrder],
    targets: &[LadderLevel],
    side: Side,
    config: &DynamicReconcileConfig,  // NEW: Contains stochastic thresholds
    queue_tracker: Option<&QueuePositionTracker>,
) -> Vec<LadderAction>
New: Dynamic Threshold Calculation

/// Dynamic thresholds from stochastic optimal spread.
#[derive(Debug, Clone)]
pub struct DynamicReconcileConfig {
    /// Base tolerance derived from optimal_spread / 4 (tight for best levels)
    pub best_level_tolerance_bps: f64,
    /// Looser tolerance for outer levels (optimal_spread / 2)
    pub outer_level_tolerance_bps: f64,
    /// Threshold for considering order "well-positioned" in queue
    pub queue_value_threshold: f64,  // P(fill) > this → preserve order
    /// Age threshold for forced refresh regardless of queue
    pub max_order_age_seconds: f64,
    /// Stochastic optimal spread (from GLFT: δ* = (1/γ)ln(1+γ/κ))
    pub optimal_spread_bps: f64,
}
impl DynamicReconcileConfig {
    /// Create from market parameters (called each quote cycle)
    pub fn from_market_params(
        gamma: f64,
        kappa: f64,
        sigma: f64,
        queue_horizon: f64,
    ) -> Self { ... }
}
[MODIFY] 
mod.rs
Update 
reconcile_ladder_smart()
 to pass stochastic parameters:

- let reconcile_config = &self.config.reconcile;
+ // Build dynamic config from current market params
+ let dynamic_config = DynamicReconcileConfig::from_market_params(
+     market_params.gamma,
+     market_params.kappa,
+     market_params.sigma,
+     1.0,  // queue_horizon_seconds
+ );
Component 2: Ladder Generation (Dynamic Order Count)
[MODIFY] 
ladder_strat.rs
Add dynamic level count respecting exchange limits:

/// Calculate optimal number of levels based on:
/// - Total spread range (from best to max depth)
/// - Minimum spacing between levels (to avoid clustering)
/// - Margin available (each order needs margin)
/// - Exchange constraints: $10 min notional, 1000 max orders
fn calculate_dynamic_level_count(
    optimal_spread_bps: f64,
    max_depth_bps: f64,
    min_level_spacing_bps: f64,
    available_margin: f64,
    mid_price: f64,
    min_size_per_level: f64,  // From margin/leverage split
) -> usize {
    // Exchange constraint: $10 minimum notional per order
    const MIN_NOTIONAL: f64 = 10.0;
    let min_size_for_notional = MIN_NOTIONAL / mid_price;
    
    // Number of viable levels based on margin
    let size_per_level = min_size_per_level.max(min_size_for_notional);
    let levels_by_margin = (available_margin / (size_per_level * mid_price))
        .floor() as usize;
    
    // Number of levels to cover spread range
    let spread_range = max_depth_bps - optimal_spread_bps;
    let levels_by_spacing = (spread_range / min_level_spacing_bps)
        .ceil() as usize + 1;  // +1 for best level
    
    // Practical limit: don't exceed reasonable API churn
    // Exchange allows 1000 orders, but we're one MM so aim for reasonable coverage
    let max_levels_per_side = 50;  // 50 bids + 50 asks = 100 orders
    
    levels_by_spacing
        .min(levels_by_margin)
        .clamp(3, max_levels_per_side)  // Min 3 for meaningful ladder
}
Component 3: Queue Position Integration
[MODIFY] 
tracker.rs
Add method to get order value for reconciliation:

/// Calculate expected value of keeping order vs refreshing.
/// Returns (should_preserve, reason) tuple.
pub fn should_preserve_order(
    &self,
    oid: u64,
    target_price: f64,
    horizon_seconds: f64,
    expected_spread_capture: f64,
) -> (bool, &'static str) {
    // Calculate current order's expected value
    let p_fill_current = self.fill_probability(oid, horizon_seconds)?;
    let ev_keep = p_fill_current * expected_spread_capture;
    
    // Estimate EV of new order at target_price (fresh queue)
    let new_depth_ahead = self.estimate_queue_at_price(target_price);
    let p_fill_new = self.estimate_fill_prob(new_depth_ahead, horizon_seconds);
    let ev_refresh = p_fill_new * expected_spread_capture;
    
    // Preserve if current EV > refresh EV (queue advantage outweighs price move)
    (ev_keep > ev_refresh, "queue_value")
}
Verification Plan
Automated Tests
Existing Tests (in 
reconcile.rs
):

cargo test -p hyperliquid_rust_sdk test_reconcile -- --nocapture
These tests verify:

Empty current → Place all targets
Matching orders → No actions
Stale orders → Cancel + Place
New Test Scenarios to Add:

Priority Matching Test: Best bid missing, far bid exists

Target: [100.0, 99.0, 98.0]
Current: [98.0] (only far level)
Expected: Place 100.0, Place 99.0, Keep 98.0
Queue Preservation Test: Order at slightly wrong price but good queue

Target: [100.00]
Current: [99.95] with queue_depth=0.1 (near front)
Expected: KEEP (queue value > price improvement)
Dynamic Threshold Test: Threshold scales with optimal spread

Tight spread (σ low) → tight threshold
Wide spread (σ high) → looser threshold
cargo test -p hyperliquid_rust_sdk priority_matching -- --nocapture
cargo test -p hyperliquid_rust_sdk queue_preservation -- --nocapture  
cargo test -p hyperliquid_rust_sdk dynamic_threshold -- --nocapture
Manual Verification
Run the market maker with logging and observe:

[Reconcile] BID levels should show local orders matching targets closely (within optimal_spread/4)
[Reconcile] Actions generated should show Place actions when best levels are missing
No more "0 actions" cycles when orders are 30+ bps from targets
Command:

./scripts/test_hip3.sh 2>&1 | grep -E "(Reconcile|Quote positions|optimal_spread)"
Implementation Order
Add DynamicReconcileConfig struct with from_market_params()
Implement priority_based_matching() in reconcile.rs
Update 
reconcile_ladder_smart()
 to use new matching
Add should_preserve_order() to QueuePositionTracker
Add unit tests for new scenarios
Run existing tests to ensure no regressions