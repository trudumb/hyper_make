//! Cycle-level diagnostic summary for observability.
//!
//! Produces one INFO-level log line per quote cycle summarizing:
//! - Warmup/phase state
//! - Spread and sizing decisions
//! - Filter pipeline effects (target vs surviving levels)
//! - Reconciler actions (placed/preserved/cancelled)
//! - Blocking reason if no orders survive
//!
//! Replaces the ~30 scattered debug/trace lines with a single actionable summary.
//! Verbose per-filter traces remain available via `RUST_LOG=trace`.

use std::fmt;

/// Summary of one quote cycle, emitted at INFO level.
#[derive(Debug, Clone)]
pub(crate) struct CycleDiagnosis {
    /// Whether the system is still warming up
    pub is_warmup: bool,
    /// Warmup progress percentage (0-100)
    pub warmup_pct: f64,
    /// Half-spread at best level (bps)
    pub spread_bps: f64,
    /// Ladder levels generated by strategy
    pub target_bid_levels: usize,
    /// Ladder levels generated by strategy
    pub target_ask_levels: usize,
    /// Levels surviving after all filters
    pub surviving_bid_levels: usize,
    /// Levels surviving after all filters
    pub surviving_ask_levels: usize,
    /// Execution mode applied
    pub execution_mode: String,
    /// Whether the system is in reduce-only mode
    pub reduce_only: bool,
    /// Reason the ladder is empty (if applicable)
    pub blocking_reason: Option<BlockingReason>,
}

/// Why the system produced zero orders this cycle.
#[derive(Debug, Clone)]
#[allow(dead_code)] // Variants wired incrementally as diagnosis coverage expands
pub(crate) enum BlockingReason {
    /// All levels removed by a specific filter
    FilteredToEmpty {
        filter: &'static str,
        levels_before: usize,
    },
    /// Size below exchange minimum after defense adjustments
    SizeBelowMinimum {
        min_required_notional: f64,
        available_notional: f64,
    },
    /// API quota exhausted
    QuotaExhausted { headroom_pct: f64 },
    /// Kill switch active
    KillSwitchActive { reason: String },
    /// Still in observation phase (not quoting yet)
    WarmupObserving,
    /// Execution mode is Flat (no quoting)
    ExecutionModeFlat,
    /// Ladder strategy produced empty ladder
    EmptyLadder,
}

impl fmt::Display for BlockingReason {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BlockingReason::FilteredToEmpty {
                filter,
                levels_before,
            } => write!(f, "filtered_to_empty({filter}, was {levels_before})"),
            BlockingReason::SizeBelowMinimum {
                min_required_notional,
                available_notional,
            } => write!(
                f,
                "size_below_min(need ${min_required_notional:.2}, have ${available_notional:.2})"
            ),
            BlockingReason::QuotaExhausted { headroom_pct } => {
                write!(f, "quota_exhausted({headroom_pct:.1}%)")
            }
            BlockingReason::KillSwitchActive { reason } => {
                write!(f, "kill_switch({reason})")
            }
            BlockingReason::WarmupObserving => write!(f, "warmup_observing"),
            BlockingReason::ExecutionModeFlat => write!(f, "execution_mode_flat"),
            BlockingReason::EmptyLadder => write!(f, "empty_ladder"),
        }
    }
}

impl CycleDiagnosis {
    /// Emit the one-line cycle summary at INFO level.
    pub(crate) fn emit(&self) {
        let phase = if self.is_warmup {
            format!("warmup({:.0}%)", self.warmup_pct)
        } else {
            "steady".to_string()
        };

        let total_target = self.target_bid_levels + self.target_ask_levels;
        let total_surviving = self.surviving_bid_levels + self.surviving_ask_levels;

        if let Some(ref reason) = self.blocking_reason {
            tracing::info!(
                phase = %phase,
                spread_bps = %format!("{:.1}", self.spread_bps),
                target = total_target,
                surviving = total_surviving,
                mode = %self.execution_mode,
                blocking = %reason,
                "cycle_summary"
            );
        } else {
            tracing::info!(
                phase = %phase,
                spread_bps = %format!("{:.1}", self.spread_bps),
                bids = self.surviving_bid_levels,
                asks = self.surviving_ask_levels,
                mode = %self.execution_mode,
                reduce_only = self.reduce_only,
                "cycle_summary"
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_diagnosis_display_warmup() {
        let d = CycleDiagnosis {
            is_warmup: true,
            warmup_pct: 45.0,
            spread_bps: 8.5,
            target_bid_levels: 3,
            target_ask_levels: 3,
            surviving_bid_levels: 2,
            surviving_ask_levels: 2,
            execution_mode: "Maker(both)".to_string(),
            reduce_only: false,
            blocking_reason: None,
        };
        // Should not panic
        d.emit();
    }

    #[test]
    fn test_diagnosis_display_blocked() {
        let d = CycleDiagnosis {
            is_warmup: false,
            warmup_pct: 100.0,
            spread_bps: 5.2,
            target_bid_levels: 3,
            target_ask_levels: 3,
            surviving_bid_levels: 0,
            surviving_ask_levels: 0,
            execution_mode: "Flat".to_string(),
            reduce_only: false,
            blocking_reason: Some(BlockingReason::ExecutionModeFlat),
        };
        d.emit();
    }

    #[test]
    fn test_blocking_reason_display() {
        let r = BlockingReason::FilteredToEmpty {
            filter: "toxicity",
            levels_before: 3,
        };
        assert_eq!(format!("{r}"), "filtered_to_empty(toxicity, was 3)");

        let r = BlockingReason::SizeBelowMinimum {
            min_required_notional: 10.0,
            available_notional: 3.5,
        };
        assert!(format!("{r}").contains("size_below_min"));

        let r = BlockingReason::QuotaExhausted { headroom_pct: 3.2 };
        assert!(format!("{r}").contains("3.2%"));
    }
}
