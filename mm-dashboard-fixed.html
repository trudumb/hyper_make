<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic MM Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.1.16/umd/Recharts.js"></script>
    <style>
        * { scrollbar-width: thin; scrollbar-color: #3a3a4a #12121a; }
        *::-webkit-scrollbar { width: 6px; height: 6px; }
        *::-webkit-scrollbar-track { background: #12121a; }
        *::-webkit-scrollbar-thumb { background-color: #3a3a4a; border-radius: 3px; }
        @keyframes pulse-glow { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
        body { font-family: 'Space Grotesk', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
    </style>
</head>
<body style="background-color: #0a0a0f; margin: 0;">
    <div id="root"></div>
    <script>
        const e = React.createElement;
        const { useState, useEffect } = React;
        const { 
            ResponsiveContainer, AreaChart, Area, BarChart, Bar, 
            XAxis, YAxis, CartesianGrid, Tooltip, Cell, ReferenceLine,
            ComposedChart, Line, Scatter
        } = Recharts;

        // Colors
        const C = {
            bg: '#0a0a0f',
            bgCard: '#12121a',
            border: '#2a2a3a',
            text: '#e4e4e7',
            textMuted: '#71717a',
            textDim: '#52525b',
            accent: '#22d3ee',
            green: '#22c55e',
            red: '#ef4444',
            yellow: '#eab308',
            purple: '#a855f7',
            orange: '#f97316',
            regimeQuiet: '#22c55e',
            regimeTrending: '#3b82f6',
            regimeVolatile: '#f97316',
            regimeCascade: '#ef4444',
        };

        // API Configuration
        const API_BASE = 'http://localhost:8080';  // Change to your market maker's metrics port
        const WS_URL = 'ws://localhost:8080/ws/dashboard';  // WebSocket endpoint

        // WebSocket Dashboard Client
        class DashboardWebSocket {
            constructor(url, onSnapshot, onUpdate, onFill, onConnected, onDisconnected) {
                this.url = url;
                this.onSnapshot = onSnapshot;
                this.onUpdate = onUpdate;
                this.onFill = onFill;
                this.onConnected = onConnected;
                this.onDisconnected = onDisconnected;
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectDelay = 5000;
                this.connected = false;
            }

            connect() {
                try {
                    this.ws = new WebSocket(this.url);

                    this.ws.onopen = () => {
                        console.log('[WS] Connected to dashboard');
                        this.connected = true;
                        this.reconnectAttempts = 0;
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const msg = JSON.parse(event.data);
                            switch (msg.type) {
                                case 'snapshot':
                                    this.onSnapshot(msg.state);
                                    break;
                                case 'update':
                                    this.onUpdate(msg);
                                    break;
                                case 'fill':
                                    this.onFill(msg.record);
                                    break;
                                case 'connected':
                                    console.log('[WS] Client ID:', msg.client_id);
                                    this.onConnected();
                                    break;
                            }
                        } catch (e) {
                            console.error('[WS] Failed to parse message:', e);
                        }
                    };

                    this.ws.onclose = () => {
                        console.log('[WS] Disconnected');
                        this.connected = false;
                        this.onDisconnected();
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('[WS] Error:', error);
                        this.connected = false;
                    };
                } catch (e) {
                    console.error('[WS] Failed to connect:', e);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts), this.maxReconnectDelay);
                this.reconnectAttempts++;
                console.log(`[WS] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                setTimeout(() => this.connect(), delay);
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Default data for when API is unavailable
        const defaultQuotes = {
            mid: '0.00',
            spreadBps: '0.0',
            inventory: '0.000',
            regime: 'Unknown',
            kappa: '0',
            gamma: '0.000',
            fillProb: '0.0',
            asProb: '0.0',
        };

        const defaultPnL = {
            spreadCapture: 0,
            adverseSelection: 0,
            inventoryCost: 0,
            fees: 0,
        };

        const defaultCalib = {
            brier: 0,
            ir: 0,
            curve: []
        };

        // Helper to generate lead-lag data (static, doesn't come from API)
        const genLeadLag = () => Array.from({length: 40}, (_, i) => {
            const lag = -200 + i * 20;
            const peak = 150;
            return {
                lag,
                r2: Math.max(0, 0.35 * Math.exp(-Math.pow(lag - peak, 2) / 20000) + Math.random() * 0.03)
            };
        });

        // API fetch function
        const fetchDashboard = async () => {
            try {
                const response = await fetch(API_BASE + '/api/dashboard');
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                return { data, connected: true };
            } catch (err) {
                console.error('Failed to fetch dashboard data:', err);
                return { data: null, connected: false };
            }
        };

        // Transform API data to component format
        const transformQuotes = (data) => ({
            mid: data.quotes.mid.toFixed(1),
            spreadBps: data.quotes.spread_bps.toFixed(1),
            inventory: data.quotes.inventory.toFixed(3),
            regime: data.quotes.regime,
            kappa: data.quotes.kappa.toFixed(0),
            gamma: data.quotes.gamma.toFixed(3),
            fillProb: data.quotes.fill_prob.toFixed(1),
            asProb: data.quotes.adverse_prob.toFixed(1),
        });

        const transformPnL = (data) => ({
            spreadCapture: data.pnl.spread_capture,
            adverseSelection: data.pnl.adverse_selection,
            inventoryCost: data.pnl.inventory_cost,
            fees: data.pnl.fees,
        });

        const transformRegimeHistory = (data) => {
            if (!data.regime.history || data.regime.history.length === 0) {
                return [];
            }
            return data.regime.history.map(h => ({
                time: h.time,
                Quiet: h.Quiet,
                Trending: h.Trending,
                Volatile: h.Volatile,
                Cascade: h.Cascade,
            }));
        };

        const transformFills = (data) => {
            if (!data.fills || data.fills.length === 0) {
                return [];
            }
            return data.fills.map(f => ({
                time: f.time,
                pnl: f.pnl,
                cumPnl: f.cumPnl,
                side: f.side,
                as: f.as
            }));
        };

        const transformCalibration = (calib) => {
            if (!calib || !calib.calibration_curve) {
                return [];
            }
            return calib.calibration_curve.map(bin => ({
                predicted: bin.predicted,
                realized: bin.realized,
                perfect: bin.predicted
            }));
        };

        const transformSignals = (data) => {
            if (!data.signals || data.signals.length === 0) {
                return [
                    { signal: 'binance_lead', mi: 0.089, corr: 0.31, lag: -150, rv: 2.3 },
                    { signal: 'trade_imb_1s', mi: 0.067, corr: 0.24, lag: 0, rv: 1.2 },
                    { signal: 'microprice_imb', mi: 0.045, corr: 0.19, lag: 0, rv: 0.8 },
                    { signal: 'funding_x_imb', mi: 0.041, corr: 0.15, lag: 0, rv: 3.1 },
                    { signal: 'oi_change_1m', mi: 0.023, corr: 0.08, lag: 0, rv: 0.6 },
                ];
            }
            return data.signals.map(s => ({
                signal: s.signal,
                mi: s.mi,
                corr: s.corr,
                lag: s.lag,
                rv: s.rv
            }));
        };

        // Components
        const Card = ({title, subtitle, accent, children}) => 
            e('div', {
                className: 'rounded-lg border overflow-hidden relative',
                style: {backgroundColor: C.bgCard, borderColor: C.border}
            },
                accent && e('div', {className: 'absolute top-0 left-0 right-0 h-0.5', style: {backgroundColor: accent}}),
                title && e('div', {className: 'px-4 py-3 border-b', style: {borderColor: C.border}},
                    e('h3', {className: 'text-sm font-medium tracking-wide uppercase mono', style: {color: C.text}}, title),
                    subtitle && e('p', {className: 'text-xs mt-0.5', style: {color: C.textMuted}}, subtitle)
                ),
                e('div', {className: 'p-4'}, children)
            );

        const Metric = ({label, value, unit}) =>
            e('div', {className: 'flex flex-col'},
                e('span', {className: 'text-xs uppercase tracking-wider mb-1 mono', style: {color: C.textMuted}}, label),
                e('div', {className: 'flex items-baseline gap-1'},
                    e('span', {className: 'text-2xl font-bold tabular-nums mono', style: {color: C.text}}, value),
                    unit && e('span', {className: 'text-sm', style: {color: C.textMuted}}, unit)
                )
            );

        const RegimeBadge = ({regime}) => {
            const colors = {Quiet: C.regimeQuiet, Trending: C.regimeTrending, Volatile: C.regimeVolatile, Cascade: C.regimeCascade};
            return e('span', {
                className: 'px-2 py-0.5 rounded text-xs font-medium uppercase tracking-wider mono',
                style: {backgroundColor: colors[regime] + '20', color: colors[regime]}
            }, regime);
        };

        const Tab = ({id, label, active, onClick}) =>
            e('button', {
                onClick: () => onClick(id),
                className: 'px-4 py-2 rounded text-xs uppercase tracking-wider transition-all whitespace-nowrap mono',
                style: {
                    backgroundColor: active ? C.accent + '20' : 'transparent',
                    color: active ? C.accent : C.textMuted,
                    border: `1px solid ${active ? C.accent + '40' : 'transparent'}`
                }
            }, label);

        // Charts
        const RegimeChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for regime data...');
            }
            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(AreaChart, {data, margin: {top: 10, right: 10, bottom: 20, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'time', tick: {fill: C.textMuted, fontSize: 9}, interval: 'preserveStartEnd'}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? (v*100).toFixed(0)+'%' : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Area, {type: 'monotone', dataKey: 'Quiet', stackId: '1', stroke: C.regimeQuiet, fill: C.regimeQuiet, fillOpacity: 0.6}),
                    e(Area, {type: 'monotone', dataKey: 'Trending', stackId: '1', stroke: C.regimeTrending, fill: C.regimeTrending, fillOpacity: 0.6}),
                    e(Area, {type: 'monotone', dataKey: 'Volatile', stackId: '1', stroke: C.regimeVolatile, fill: C.regimeVolatile, fillOpacity: 0.6}),
                    e(Area, {type: 'monotone', dataKey: 'Cascade', stackId: '1', stroke: C.regimeCascade, fill: C.regimeCascade, fillOpacity: 0.6})
                )
            );
        };

        const PnLChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for fill data...');
            }
            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(AreaChart, {data, margin: {top: 10, right: 10, bottom: 20, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'time', tick: {fill: C.textMuted, fontSize: 9}, interval: 'preserveStartEnd'}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? '$'+v.toFixed(0) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(ReferenceLine, {y: 0, stroke: C.textDim, strokeDasharray: '3 3'}),
                    e(Area, {type: 'monotone', dataKey: 'cumPnl', stroke: C.accent, fill: C.accent, fillOpacity: 0.2})
                )
            );
        };

        const WaterfallChart = ({data}) => {
            const items = [
                {name: 'Spread', value: data?.spreadCapture || 0, fill: C.green},
                {name: 'Adverse', value: data?.adverseSelection || 0, fill: C.red},
                {name: 'Inventory', value: data?.inventoryCost || 0, fill: C.orange},
                {name: 'Fees', value: data?.fees || 0, fill: C.purple},
            ];
            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(BarChart, {data: items, margin: {top: 10, right: 10, bottom: 20, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'name', tick: {fill: C.textMuted, fontSize: 9}}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? '$'+v.toFixed(0) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(ReferenceLine, {y: 0, stroke: C.textDim}),
                    e(Bar, {dataKey: 'value', radius: [4, 4, 0, 0]},
                        items.map((item, i) => e(Cell, {key: i, fill: item.fill}))
                    )
                )
            );
        };

        const LeadLagChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...');
            }
            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(AreaChart, {data, margin: {top: 10, right: 10, bottom: 20, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'lag', tick: {fill: C.textMuted, fontSize: 10}}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? v.toFixed(2) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(ReferenceLine, {x: 0, stroke: C.textDim, strokeDasharray: '3 3'}),
                    e(Area, {type: 'monotone', dataKey: 'r2', stroke: C.purple, fill: C.purple, fillOpacity: 0.3})
                )
            );
        };

        const CalibrationChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for calibration data...');
            }
            return e(ResponsiveContainer, {width: '100%', height: 250},
                e(ComposedChart, {data, margin: {top: 10, right: 10, bottom: 20, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'predicted', tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? v.toFixed(1) : ''}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v != null ? v.toFixed(1) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Line, {type: 'monotone', dataKey: 'perfect', stroke: C.textDim, strokeDasharray: '5 5', dot: false}),
                    e(Scatter, {dataKey: 'realized', fill: C.accent})
                )
            );
        };

        const SignalTable = ({data}) =>
            e('table', {className: 'w-full text-xs mono'},
                e('thead', null,
                    e('tr', {style: {borderBottom: `1px solid ${C.border}`}},
                        e('th', {className: 'text-left py-2 px-2', style: {color: C.textMuted}}, 'SIGNAL'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'MI'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'CORR'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'LAG'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'VAR')
                    )
                ),
                e('tbody', null,
                    data.map((row, i) =>
                        e('tr', {key: i, style: {borderBottom: `1px solid ${C.border}`, backgroundColor: i % 2 ? C.bgCard : 'transparent'}},
                            e('td', {className: 'py-2 px-2', style: {color: C.text}}, row.signal),
                            e('td', {className: 'text-right py-2 px-2', style: {color: C.accent}}, row.mi.toFixed(3)),
                            e('td', {className: 'text-right py-2 px-2', style: {color: C.text}}, row.corr.toFixed(2)),
                            e('td', {className: 'text-right py-2 px-2', style: {color: row.lag !== 0 ? C.yellow : C.textMuted}}, row.lag + 'ms'),
                            e('td', {className: 'text-right py-2 px-2', style: {color: row.rv > 2 ? C.orange : C.textMuted}}, row.rv.toFixed(1) + 'x')
                        )
                    )
                )
            );

        // ============================================================================
        // NEW VISUALIZATION COMPONENTS
        // ============================================================================

        // 2D Order Book Heat Map
        const BookHeatMap = ({data, quoteData}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for order book data...');
            }
            // Transform book history into heat map points
            const heatData = [];
            const minPrice = Math.min(...data.flatMap(d => [...d.bids.map(b => b.price), ...d.asks.map(a => a.price)]));
            const maxPrice = Math.max(...data.flatMap(d => [...d.bids.map(b => b.price), ...d.asks.map(a => a.price)]));
            const maxSize = Math.max(...data.flatMap(d => [...d.bids.map(b => b.size), ...d.asks.map(a => a.size)]));

            data.forEach((snapshot, timeIdx) => {
                snapshot.bids.forEach(level => {
                    heatData.push({
                        time: snapshot.time,
                        timeIdx,
                        price: level.price,
                        size: level.size,
                        intensity: level.size / maxSize,
                        side: 'bid'
                    });
                });
                snapshot.asks.forEach(level => {
                    heatData.push({
                        time: snapshot.time,
                        timeIdx,
                        price: level.price,
                        size: level.size,
                        intensity: level.size / maxSize,
                        side: 'ask'
                    });
                });
            });

            return e(ResponsiveContainer, {width: '100%', height: 300},
                e(ComposedChart, {data: heatData, margin: {top: 10, right: 10, bottom: 30, left: 60}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'timeIdx', tick: {fill: C.textMuted, fontSize: 9}, tickFormatter: (v) => data[v]?.time || ''}),
                    e(YAxis, {dataKey: 'price', domain: [minPrice * 0.9999, maxPrice * 1.0001], tick: {fill: C.textMuted, fontSize: 9}, tickFormatter: v => v ? v.toFixed(0) : ''}),
                    e(Tooltip, {
                        contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11},
                        formatter: (value, name) => [value?.toFixed ? value.toFixed(4) : value, name]
                    }),
                    e(Scatter, {dataKey: 'price', fill: C.green},
                        heatData.filter(d => d.side === 'bid').map((entry, i) =>
                            e(Cell, {key: i, fill: `rgba(34, 197, 94, ${0.2 + entry.intensity * 0.8})`})
                        )
                    ),
                    e(Scatter, {dataKey: 'price', data: heatData.filter(d => d.side === 'ask')},
                        heatData.filter(d => d.side === 'ask').map((entry, i) =>
                            e(Cell, {key: i, fill: `rgba(239, 68, 68, ${0.2 + entry.intensity * 0.8})`})
                        )
                    )
                )
            );
        };

        // Live Mid Price Chart with Quote Overlay
        const PriceChart = ({priceData, quoteData}) => {
            if (!priceData || priceData.length === 0) {
                return e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for price data...');
            }
            // Merge price data with quote bands
            const mergedData = priceData.map(p => {
                const quote = quoteData?.find(q => q.time === p.time);
                return {
                    ...p,
                    bestBid: quote?.bid_prices?.[0] || null,
                    bestAsk: quote?.ask_prices?.[0] || null
                };
            });

            return e(ResponsiveContainer, {width: '100%', height: 280},
                e(ComposedChart, {data: mergedData, margin: {top: 10, right: 10, bottom: 30, left: 60}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'time', tick: {fill: C.textMuted, fontSize: 9}, interval: 'preserveStartEnd'}),
                    e(YAxis, {domain: ['auto', 'auto'], tick: {fill: C.textMuted, fontSize: 9}, tickFormatter: v => v ? v.toFixed(0) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Area, {type: 'monotone', dataKey: 'bestBid', stroke: 'transparent', fill: C.green, fillOpacity: 0.15}),
                    e(Area, {type: 'monotone', dataKey: 'bestAsk', stroke: 'transparent', fill: C.red, fillOpacity: 0.15}),
                    e(Line, {type: 'monotone', dataKey: 'price', stroke: C.accent, strokeWidth: 2, dot: false}),
                    e(Line, {type: 'monotone', dataKey: 'bestBid', stroke: C.green, strokeWidth: 1, strokeDasharray: '3 3', dot: false}),
                    e(Line, {type: 'monotone', dataKey: 'bestAsk', stroke: C.red, strokeWidth: 1, strokeDasharray: '3 3', dot: false})
                )
            );
        };

        // Spread Distribution Histogram
        const SpreadHistogram = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for spread data...');
            }
            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(BarChart, {data, margin: {top: 10, right: 10, bottom: 30, left: 10}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'range_bps', tick: {fill: C.textMuted, fontSize: 10}, label: {value: 'Spread (bps)', position: 'bottom', fill: C.textMuted, fontSize: 10}}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v ? v.toFixed(0) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Bar, {dataKey: 'count', fill: C.purple, radius: [4, 4, 0, 0]})
                )
            );
        };

        // Quote Fill Rate by Level
        const FillRateChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for fill data...');
            }
            // Group by level
            const byLevel = {};
            data.forEach(d => {
                if (!byLevel[d.level]) byLevel[d.level] = {level: d.level, bid: 0, ask: 0};
                if (d.side === 'BID') byLevel[d.level].bid = d.fill_count;
                else byLevel[d.level].ask = d.fill_count;
            });
            const chartData = Object.values(byLevel).sort((a, b) => a.level - b.level);

            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(BarChart, {data: chartData, layout: 'vertical', margin: {top: 10, right: 10, bottom: 10, left: 40}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {type: 'number', tick: {fill: C.textMuted, fontSize: 10}}),
                    e(YAxis, {type: 'category', dataKey: 'level', tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => `L${v}`}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Bar, {dataKey: 'bid', fill: C.green, name: 'Bid Fills'}),
                    e(Bar, {dataKey: 'ask', fill: C.red, name: 'Ask Fills'})
                )
            );
        };

        // Current Book Depth (snapshot)
        const DepthChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for book data...');
            }
            const latest = data[data.length - 1];
            if (!latest) return null;

            // Build cumulative depth
            let bidCum = 0, askCum = 0;
            const bidDepth = latest.bids.map(b => { bidCum += b.size; return {price: b.price, cumSize: bidCum, side: 'bid'}; });
            const askDepth = latest.asks.map(a => { askCum += a.size; return {price: a.price, cumSize: askCum, side: 'ask'}; });
            const depthData = [...bidDepth.reverse(), ...askDepth];

            return e(ResponsiveContainer, {width: '100%', height: 200},
                e(AreaChart, {data: depthData, margin: {top: 10, right: 10, bottom: 20, left: 60}},
                    e(CartesianGrid, {strokeDasharray: '3 3', stroke: C.border}),
                    e(XAxis, {dataKey: 'price', tick: {fill: C.textMuted, fontSize: 9}, tickFormatter: v => v ? v.toFixed(0) : ''}),
                    e(YAxis, {tick: {fill: C.textMuted, fontSize: 10}, tickFormatter: v => v ? v.toFixed(2) : ''}),
                    e(Tooltip, {contentStyle: {backgroundColor: C.bgCard, border: `1px solid ${C.border}`, borderRadius: 4, fontSize: 11}}),
                    e(Area, {type: 'stepAfter', dataKey: 'cumSize', stroke: C.accent, fill: C.accent, fillOpacity: 0.3})
                )
            );
        };

        // Main Dashboard
        const Dashboard = () => {
            const [tab, setTab] = useState('overview');
            const [connected, setConnected] = useState(false);
            const [quotes, setQuotes] = useState(defaultQuotes);
            const [regime, setRegime] = useState([]);
            const [pnl, setPnl] = useState(defaultPnL);
            const [fills, setFills] = useState([]);
            const [calib, setCalib] = useState([]);
            const [calibMetrics, setCalibMetrics] = useState({ fill: defaultCalib, as: defaultCalib });
            const [signals, setSignals] = useState([]);
            const [leadLag, setLeadLag] = useState(genLeadLag());
            const [time, setTime] = useState(new Date().toLocaleTimeString());

            // New visualization state
            const [bookHistory, setBookHistory] = useState([]);
            const [priceHistory, setPriceHistory] = useState([]);
            const [quoteHistory, setQuoteHistory] = useState([]);
            const [spreadDist, setSpreadDist] = useState([]);
            const [fillStats, setFillStats] = useState([]);

            // Track accumulated fills from WebSocket
            const [wsConnected, setWsConnected] = useState(false);

            // Apply full state from snapshot
            const applySnapshot = (data) => {
                if (data) {
                    setQuotes(transformQuotes(data));
                    setPnl(transformPnL(data));
                    setRegime(transformRegimeHistory(data));
                    setFills(transformFills(data));
                    setCalib(transformCalibration(data.calibration?.fill));
                    setCalibMetrics({
                        fill: {
                            brier: data.calibration?.fill?.brier_score || 0,
                            ir: data.calibration?.fill?.information_ratio || 0,
                        },
                        as: {
                            brier: data.calibration?.adverse_selection?.brier_score || 0,
                            ir: data.calibration?.adverse_selection?.information_ratio || 0,
                        }
                    });
                    setSignals(transformSignals(data));
                    // New visualization data
                    if (data.book_history) setBookHistory(data.book_history);
                    if (data.price_history) setPriceHistory(data.price_history);
                    if (data.quote_history) setQuoteHistory(data.quote_history);
                    if (data.spread_distribution) setSpreadDist(data.spread_distribution);
                    if (data.quote_fill_stats) setFillStats(data.quote_fill_stats);
                }
                setTime(new Date().toLocaleTimeString());
            };

            // Apply incremental update
            const applyUpdate = (update) => {
                if (update.quotes) {
                    setQuotes({
                        mid: update.quotes.mid.toFixed(1),
                        spreadBps: update.quotes.spread_bps.toFixed(1),
                        inventory: update.quotes.inventory.toFixed(3),
                        regime: update.quotes.regime,
                        kappa: update.quotes.kappa.toFixed(0),
                        gamma: update.quotes.gamma.toFixed(3),
                        fillProb: update.quotes.fill_prob.toFixed(1),
                        asProb: update.quotes.adverse_prob.toFixed(1),
                    });
                }
                if (update.pnl) {
                    setPnl({
                        spreadCapture: update.pnl.spread_capture,
                        adverseSelection: update.pnl.adverse_selection,
                        inventoryCost: update.pnl.inventory_cost,
                        fees: update.pnl.fees,
                    });
                }
                if (update.regime) {
                    // Could update regime state here
                }
                setTime(new Date().toLocaleTimeString());
            };

            // Add new fill to fills array
            const addFill = (record) => {
                setFills(prev => [...prev.slice(-99), {
                    time: record.time,
                    pnl: record.pnl,
                    cumPnl: record.cum_pnl,
                    side: record.side,
                    as: record.adverse_selection
                }]);
            };

            // Connect via WebSocket with HTTP fallback
            useEffect(() => {
                let wsClient = null;
                let httpFallbackInterval = null;

                // Create WebSocket client
                wsClient = new DashboardWebSocket(
                    WS_URL,
                    applySnapshot,  // onSnapshot
                    applyUpdate,    // onUpdate
                    addFill,        // onFill
                    () => {         // onConnected
                        setConnected(true);
                        setWsConnected(true);
                        // Clear HTTP fallback if running
                        if (httpFallbackInterval) {
                            clearInterval(httpFallbackInterval);
                            httpFallbackInterval = null;
                        }
                    },
                    () => {         // onDisconnected
                        setConnected(false);
                        setWsConnected(false);
                        // Start HTTP fallback polling
                        if (!httpFallbackInterval) {
                            httpFallbackInterval = setInterval(async () => {
                                const { data, connected: isConnected } = await fetchDashboard();
                                if (isConnected && data) {
                                    setConnected(true);
                                    applySnapshot(data);
                                }
                            }, 1000);
                        }
                    }
                );

                // Start WebSocket connection
                wsClient.connect();

                return () => {
                    if (wsClient) wsClient.close();
                    if (httpFallbackInterval) clearInterval(httpFallbackInterval);
                };
            }, []);

            const tabs = [
                {id: 'overview', label: 'Overview'},
                {id: 'book', label: 'Order Book'},
                {id: 'calibration', label: 'Calibration'},
                {id: 'regime', label: 'Regime'},
                {id: 'signals', label: 'Signals'},
                {id: 'pnl', label: 'PnL'}
            ];

            return e('div', {className: 'min-h-screen p-4 md:p-6', style: {backgroundColor: C.bg, color: C.text}},
                // Header
                e('header', {className: 'mb-6'},
                    e('div', {className: 'flex flex-col md:flex-row md:items-center md:justify-between gap-4'},
                        e('div', null,
                            e('h1', {className: 'text-2xl md:text-3xl font-bold tracking-tight'}, 'STOCHASTIC MM'),
                            e('p', {className: 'text-sm mt-1', style: {color: C.textMuted}}, 'Real-time Market Making Analytics • Hyperliquid BTC-PERP')
                        ),
                        e('div', {className: 'flex items-center gap-4'},
                            e('div', {className: 'flex items-center gap-2'},
                                e('div', {className: 'w-2 h-2 rounded-full pulse-glow', style: {backgroundColor: connected ? C.green : C.red}}),
                                e('span', {className: 'text-xs uppercase tracking-wider mono', style: {color: C.textMuted}},
                                    connected ? (wsConnected ? 'WS Live' : 'HTTP') : 'Disconnected')
                            ),
                            e('span', {className: 'text-xs tabular-nums mono', style: {color: C.textMuted}}, time)
                        )
                    ),
                    e('nav', {className: 'flex gap-1 mt-6 overflow-x-auto pb-2'},
                        tabs.map(t => e(Tab, {key: t.id, id: t.id, label: t.label, active: tab === t.id, onClick: setTab}))
                    )
                ),

                // Live Banner
                e(Card, {accent: C.accent},
                    e('div', {className: 'grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4'},
                        e(Metric, {label: 'Mid Price', value: quotes.mid, unit: 'USD'}),
                        e(Metric, {label: 'Spread', value: quotes.spreadBps, unit: 'bps'}),
                        e(Metric, {label: 'Inventory', value: quotes.inventory, unit: 'BTC'}),
                        e('div', {className: 'flex flex-col'},
                            e('span', {className: 'text-xs uppercase tracking-wider mb-1 mono', style: {color: C.textMuted}}, 'Regime'),
                            e(RegimeBadge, {regime: quotes.regime})
                        ),
                        e(Metric, {label: 'Kappa', value: quotes.kappa}),
                        e(Metric, {label: 'Gamma', value: quotes.gamma}),
                        e(Metric, {label: 'P(Fill)', value: quotes.fillProb, unit: '%'}),
                        e(Metric, {label: 'P(Adverse)', value: quotes.asProb, unit: '%'})
                    )
                ),

                // Content
                e('div', {className: 'mt-6'},
                    tab === 'overview' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Cumulative PnL', subtitle: 'Last hour', accent: C.green}, e(PnLChart, {data: fills})),
                        e(Card, {title: 'PnL Attribution', subtitle: 'Component breakdown', accent: C.purple}, e(WaterfallChart, {data: pnl})),
                        e(Card, {title: 'Regime Probabilities', subtitle: 'HMM belief state', accent: C.regimeTrending}, e(RegimeChart, {data: regime})),
                        e(Card, {title: 'Fill Calibration', subtitle: 'Predicted vs realized', accent: C.accent}, e(CalibrationChart, {data: calib}))
                    ),

                    tab === 'book' && e('div', {className: 'space-y-6'},
                        // Top row: Price Chart (full width)
                        e(Card, {title: 'Mid Price History', subtitle: '30-minute rolling window', accent: C.accent, className: 'lg:col-span-2'},
                            e(PriceChart, {priceData: priceHistory, quoteData: quoteHistory})
                        ),
                        // Second row: Heat Map and Depth
                        e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                            e(Card, {title: 'Order Book Heat Map', subtitle: 'Time × Price with size intensity', accent: C.purple},
                                e(BookHeatMap, {data: bookHistory, quoteData: quoteHistory})
                            ),
                            e(Card, {title: 'Current Book Depth', subtitle: 'Bid/Ask liquidity profile', accent: C.accent},
                                bookHistory.length > 0
                                    ? e(DepthChart, {data: bookHistory[bookHistory.length - 1]})
                                    : e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for book data...')
                            )
                        ),
                        // Third row: Quote Distribution
                        e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                            e(Card, {title: 'Spread Distribution', subtitle: 'Histogram of realized spreads', accent: C.orange},
                                spreadDist.length > 0
                                    ? e(SpreadHistogram, {data: spreadDist})
                                    : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting spread data...')
                            ),
                            e(Card, {title: 'Fill Rate by Level', subtitle: 'Which quote levels get filled', accent: C.green},
                                fillStats.length > 0
                                    ? e(FillRateChart, {data: fillStats})
                                    : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting fill data...')
                            )
                        ),
                        // Stats summary
                        e('div', {className: 'grid grid-cols-2 md:grid-cols-4 gap-4'},
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.accent}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Price Points'),
                                e('div', {className: 'text-2xl font-bold mono'}, priceHistory.length)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.purple}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Book Snapshots'),
                                e('div', {className: 'text-2xl font-bold mono'}, bookHistory.length)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.orange}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Spread Samples'),
                                e('div', {className: 'text-2xl font-bold mono'}, spreadDist.reduce((a, b) => a + b.count, 0))
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.green}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Total Fills'),
                                e('div', {className: 'text-2xl font-bold mono'}, fillStats.reduce((a, b) => a + b.fill_count, 0))
                            )
                        )
                    ),

                    tab === 'calibration' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Fill Probability Calibration', accent: C.accent},
                            calib.length > 0 ? e(CalibrationChart, {data: calib}) : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...'),
                            e('div', {className: 'mt-4 grid grid-cols-2 gap-4'},
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Brier Score'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.fill.brier.toFixed(3)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.fill.brier < 0.25 ? C.green : calibMetrics.fill.brier < 0.35 ? C.yellow : C.red}}, calibMetrics.fill.brier < 0.25 ? 'Good' : calibMetrics.fill.brier < 0.35 ? 'Fair' : 'Poor')
                                ),
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Info Ratio'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.fill.ir.toFixed(2)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.fill.ir > 1.0 ? C.green : calibMetrics.fill.ir > 0.8 ? C.yellow : C.red}}, calibMetrics.fill.ir > 1.0 ? 'Predictive' : calibMetrics.fill.ir > 0.8 ? 'Marginal' : 'No edge')
                                )
                            )
                        ),
                        e(Card, {title: 'Adverse Selection Calibration', accent: C.red},
                            e(CalibrationChart, {data: transformCalibration(null)}),
                            e('div', {className: 'mt-4 grid grid-cols-2 gap-4'},
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Brier Score'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.as.brier.toFixed(3)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.as.brier < 0.25 ? C.green : calibMetrics.as.brier < 0.35 ? C.yellow : C.red}}, calibMetrics.as.brier < 0.25 ? 'Good' : calibMetrics.as.brier < 0.35 ? 'Fair' : 'Poor')
                                ),
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Info Ratio'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.as.ir.toFixed(2)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.as.ir > 1.0 ? C.green : calibMetrics.as.ir > 0.8 ? C.yellow : C.red}}, calibMetrics.as.ir > 1.0 ? 'Predictive' : calibMetrics.as.ir > 0.8 ? 'Marginal' : 'No edge')
                                )
                            )
                        )
                    ),

                    tab === 'regime' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Regime History', subtitle: 'HMM belief evolution', accent: C.regimeTrending, className: 'lg:col-span-2'},
                            e(RegimeChart, {data: regime}),
                            e('div', {className: 'flex gap-4 mt-4 flex-wrap'},
                                ['Quiet', 'Trending', 'Volatile', 'Cascade'].map(r =>
                                    e('div', {key: r, className: 'flex items-center gap-2'},
                                        e('div', {className: 'w-3 h-3 rounded', style: {backgroundColor: C['regime' + r]}}),
                                        e('span', {className: 'text-xs', style: {color: C.textMuted}}, r)
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Regime Parameters', accent: C.accent},
                            e('div', {className: 'space-y-4'},
                                [{r: 'Quiet', g: 0.3, k: 1.0, f: 5}, {r: 'Trending', g: 0.5, k: 0.7, f: 10}, {r: 'Volatile', g: 0.8, k: 1.5, f: 15}, {r: 'Cascade', g: 2.0, k: 5.0, f: 50}].map(p =>
                                    e('div', {key: p.r, className: 'p-3 rounded border flex items-center justify-between', style: {backgroundColor: C.bg, borderColor: C.border, borderLeftWidth: 3, borderLeftColor: C['regime' + p.r]}},
                                        e(RegimeBadge, {regime: p.r}),
                                        e('div', {className: 'flex gap-4 text-xs mono', style: {color: C.textMuted}},
                                            e('span', null, 'γ=' + p.g),
                                            e('span', null, 'κ×' + p.k),
                                            e('span', null, p.f + 'bps')
                                        )
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Current Blended', accent: C.green},
                            e('div', {className: 'grid grid-cols-2 gap-4'},
                                e(Metric, {label: 'Eff. Gamma', value: quotes.gamma}),
                                e(Metric, {label: 'Kappa Mult', value: '1.15'}),
                                e(Metric, {label: 'Floor', value: '8.0', unit: 'bps'}),
                                e(Metric, {label: 'Max Inv', value: '0.65', unit: 'BTC'})
                            )
                        )
                    ),

                    tab === 'signals' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Signal Audit', subtitle: 'Mutual information analysis', accent: C.accent, className: 'lg:col-span-2'},
                            signals.length > 0 ? e(SignalTable, {data: signals}) : e('div', {className: 'h-24 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...'),
                            signals.length > 0 && e('div', {className: 'mt-4 p-3 rounded border', style: {backgroundColor: C.bg, borderColor: C.border}},
                                e('span', {className: 'text-xs', style: {color: C.textMuted}},
                                    e('strong', {style: {color: C.accent}}, 'Key: '),
                                    signals[0]?.signal + ' (' + signals[0]?.mi.toFixed(3) + ' bits, ' + signals[0]?.lag + 'ms lag)'
                                )
                            )
                        ),
                        e(Card, {title: 'Cross-Exchange Lead-Lag', subtitle: 'Binance → Hyperliquid', accent: C.purple},
                            e(LeadLagChart, {data: leadLag}),
                            e('div', {className: 'grid grid-cols-3 gap-4 mt-4'},
                                e(Metric, {label: 'Opt Lag', value: '150', unit: 'ms'}),
                                e(Metric, {label: 'Peak R²', value: '0.32'}),
                                e(Metric, {label: 'Beta', value: '0.87'})
                            )
                        ),
                        e(Card, {title: 'MI by Signal', accent: C.green},
                            signals.length > 0 ? e('div', {className: 'space-y-3'},
                                signals.map((s, i) =>
                                    e('div', {key: i},
                                        e('div', {className: 'flex justify-between mb-1'},
                                            e('span', {className: 'text-xs', style: {color: C.text}}, s.signal),
                                            e('span', {className: 'text-xs tabular-nums mono', style: {color: C.accent}}, s.mi.toFixed(3))
                                        ),
                                        e('div', {className: 'h-1.5 rounded-full overflow-hidden', style: {backgroundColor: C.border}},
                                            e('div', {className: 'h-full rounded-full', style: {width: (s.mi / 0.1 * 100) + '%', backgroundColor: C.accent}})
                                        )
                                    )
                                )
                            ) : e('div', {className: 'h-24 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...')
                        )
                    ),

                    tab === 'pnl' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'PnL Attribution', accent: C.green},
                            e(WaterfallChart, {data: pnl}),
                            e('div', {className: 'mt-4 p-3 rounded mono text-xs', style: {backgroundColor: C.bg}},
                                e('span', {style: {color: C.textMuted}}, 'Gross: '),
                                e('span', {style: {color: (pnl.spreadCapture + pnl.adverseSelection + pnl.inventoryCost + pnl.fees) >= 0 ? C.green : C.red}},
                                    '$' + (pnl.spreadCapture + pnl.adverseSelection + pnl.inventoryCost + pnl.fees).toFixed(2)
                                )
                            )
                        ),
                        e(Card, {title: 'Cumulative', accent: C.accent}, e(PnLChart, {data: fills})),
                        e(Card, {title: 'By Regime', accent: C.purple},
                            e('div', {className: 'space-y-4'},
                                [{r: 'Quiet', pnl: 89.20, pct: 68}, {r: 'Trending', pnl: -45.60, pct: 28}, {r: 'Volatile', pnl: -12.30, pct: 3.5}, {r: 'Cascade', pnl: -158.75, pct: 0.5}].map(x =>
                                    e('div', {key: x.r, className: 'flex items-center gap-4'},
                                        e('div', {className: 'w-20'}, e(RegimeBadge, {regime: x.r})),
                                        e('div', {className: 'flex-1'},
                                            e('div', {className: 'h-1.5 rounded-full overflow-hidden', style: {backgroundColor: C.border}},
                                                e('div', {className: 'h-full rounded-full', style: {width: (x.pct) + '%', backgroundColor: C['regime' + x.r]}})
                                            )
                                        ),
                                        e('span', {className: 'w-16 text-right text-xs tabular-nums mono', style: {color: x.pnl >= 0 ? C.green : C.red}}, '$' + x.pnl.toFixed(0)),
                                        e('span', {className: 'w-10 text-right text-xs', style: {color: C.textMuted}}, x.pct + '%')
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Recent Fills', accent: C.orange},
                            e('div', {className: 'space-y-2 max-h-64 overflow-y-auto'},
                                fills.slice(-10).reverse().map((f, i) =>
                                    e('div', {key: i, className: 'flex items-center justify-between p-2 rounded text-xs mono', style: {backgroundColor: i % 2 === 0 ? C.bg : 'transparent'}},
                                        e('span', {style: {color: C.textMuted}}, f.time),
                                        e('span', {style: {color: f.side === 'BID' ? C.green : C.red}}, f.side),
                                        e('span', {style: {color: f.pnl >= 0 ? C.green : C.red}}, (f.pnl >= 0 ? '+' : '') + '$' + f.pnl.toFixed(2)),
                                        e('span', {style: {color: C.textMuted}}, 'AS:' + f.as)
                                    )
                                )
                            )
                        )
                    )
                ),

                // Footer
                e('footer', {className: 'mt-8 pt-6 border-t text-center', style: {borderColor: C.border}},
                    e('p', {className: 'text-xs', style: {color: C.textMuted}}, 'Stochastic Market Making Dashboard • Building in Public'),
                    e('p', {className: 'text-xs mt-1', style: {color: C.textDim}}, 'From GLFT theory to profitable execution')
                )
            );
        };

        ReactDOM.render(e(Dashboard), document.getElementById('root'));
    </script>
</body>
</html>
