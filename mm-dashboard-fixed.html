<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic MM Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- Canvas-based charting libraries (replacing Recharts) -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.28/dist/uPlot.iife.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.28/dist/uPlot.min.css">
    <style>
        * { scrollbar-width: thin; scrollbar-color: #3a3a4a #12121a; }
        *::-webkit-scrollbar { width: 6px; height: 6px; }
        *::-webkit-scrollbar-track { background: #12121a; }
        *::-webkit-scrollbar-thumb { background-color: #3a3a4a; border-radius: 3px; }
        @keyframes pulse-glow { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
        body { font-family: 'Space Grotesk', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        /* uPlot dark theme overrides */
        .uplot { font-family: 'JetBrains Mono', monospace; }
        .uplot .u-legend { display: none; }
        .u-wrap { background: transparent !important; }
    </style>
</head>
<body style="background-color: #0a0a0f; margin: 0;">
    <div id="root"></div>
    <script>
        const e = React.createElement;
        const { useState, useEffect, useRef, useCallback } = React;

        // ============================================================================
        // CHART THEME CONFIGURATIONS
        // ============================================================================

        // uPlot dark theme base options
        const uPlotDarkTheme = {
            axes: [
                { stroke: '#71717a', grid: { stroke: '#2a2a3a', width: 1 }, ticks: { stroke: '#2a2a3a' } },
                { stroke: '#71717a', grid: { stroke: '#2a2a3a', width: 1 }, ticks: { stroke: '#2a2a3a' } }
            ],
            cursor: { show: true, x: true, y: true, drag: { x: false, y: false } }
        };

        // lightweight-charts dark theme
        const lwcDarkTheme = {
            layout: {
                background: { type: 'solid', color: '#12121a' },
                textColor: '#71717a',
                fontFamily: 'JetBrains Mono, monospace',
                fontSize: 10
            },
            grid: {
                vertLines: { color: '#2a2a3a' },
                horzLines: { color: '#2a2a3a' }
            },
            crosshair: { mode: 1 },
            timeScale: { borderColor: '#2a2a3a', timeVisible: true },
            rightPriceScale: { borderColor: '#2a2a3a' }
        };

        // ============================================================================
        // CHART SYNCHRONIZATION MANAGER
        // ============================================================================

        class ChartSyncManager {
            constructor(windowDurationMs = 30 * 60 * 1000) {
                this.windowDurationMs = windowDurationMs;
                this.charts = new Map();  // chartId -> { type, instance, adapter }
                this.timeRange = { from: null, to: null };
                this.cursorTimestamp = null;
                this.listeners = new Set();
                this.isProgrammaticUpdate = false;
            }

            // Register a chart with its adapter
            register(chartId, type, instance, adapter) {
                this.charts.set(chartId, { type, instance, adapter });
            }

            unregister(chartId) {
                this.charts.delete(chartId);
            }

            // Set the visible time range (called by any chart)
            setTimeRange(from, to, sourceChartId = null) {
                if (this.isProgrammaticUpdate) return;

                this.timeRange = { from, to };
                this.isProgrammaticUpdate = true;

                this.charts.forEach((chart, chartId) => {
                    if (chartId !== sourceChartId && chart.adapter?.setTimeRange) {
                        chart.adapter.setTimeRange(from, to);
                    }
                });

                this.isProgrammaticUpdate = false;
                this.notifyListeners('timeRange', { from, to });
            }

            // Set cursor position (called by any chart on crosshair move)
            setCursor(timestamp, sourceChartId = null) {
                if (this.isProgrammaticUpdate) return;

                this.cursorTimestamp = timestamp;
                this.isProgrammaticUpdate = true;

                this.charts.forEach((chart, chartId) => {
                    if (chartId !== sourceChartId && chart.adapter?.setCursor) {
                        chart.adapter.setCursor(timestamp);
                    }
                });

                this.isProgrammaticUpdate = false;
                this.notifyListeners('cursor', { timestamp });
            }

            // Clear cursor (mouse left chart area)
            clearCursor(sourceChartId = null) {
                this.cursorTimestamp = null;
                this.charts.forEach((chart, chartId) => {
                    if (chartId !== sourceChartId && chart.adapter?.clearCursor) {
                        chart.adapter.clearCursor();
                    }
                });
            }

            // Convert timestamp to data index for a given dataset (binary search)
            timestampToIndex(timestamp, data, timestampField = 'timestamp_ms') {
                if (!data || data.length === 0 || !timestamp) return null;

                let left = 0, right = data.length - 1;
                while (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    const ts = data[mid][timestampField] || data[mid].timestamp_ms;
                    if (ts < timestamp) left = mid + 1;
                    else right = mid;
                }
                return left;
            }

            // Convert index to timestamp for a given dataset
            indexToTimestamp(index, data, timestampField = 'timestamp_ms') {
                if (!data || index < 0 || index >= data.length) return null;
                return data[index][timestampField] || data[index].timestamp_ms;
            }

            // Calculate 30-minute rolling window boundaries
            getDefaultTimeRange() {
                const now = Date.now();
                return {
                    from: now - this.windowDurationMs,
                    to: now
                };
            }

            addListener(callback) {
                this.listeners.add(callback);
            }

            removeListener(callback) {
                this.listeners.delete(callback);
            }

            notifyListeners(event, data) {
                this.listeners.forEach(cb => cb(event, data));
            }
        }

        // ============================================================================
        // CANVAS CHART WRAPPER COMPONENTS
        // ============================================================================

        // Generic uPlot wrapper component
        const UPlotChart = ({ data, options, width, height }) => {
            const containerRef = useRef(null);
            const chartRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current || !data || data.length === 0 || !data[0]?.length) return;

                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                    chartRef.current = null;
                }

                // Merge options with theme
                const opts = {
                    ...uPlotDarkTheme,
                    ...options,
                    width: width || containerRef.current.offsetWidth || 400,
                    height: height || 200,
                    axes: options.axes || uPlotDarkTheme.axes
                };

                try {
                    chartRef.current = new uPlot(opts, data, containerRef.current);
                } catch (err) {
                    console.error('uPlot error:', err);
                }

                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                        chartRef.current = null;
                    }
                };
            }, [data, options, width, height]);

            return e('div', { ref: containerRef, style: { width: '100%', height: height || 200 } });
        };

        // lightweight-charts wrapper for price chart
        const LWCPriceChart = ({ priceData, quoteData, width, height, syncManager }) => {
            const containerRef = useRef(null);
            const chartRef = useRef(null);
            const seriesRef = useRef({});
            const adapterRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;

                // Create chart with zoom/pan enabled
                const chart = LightweightCharts.createChart(containerRef.current, {
                    ...lwcDarkTheme,
                    width: width || containerRef.current.offsetWidth || 400,
                    height: height || 350,
                    handleScroll: true,
                    handleScale: true
                });
                chartRef.current = chart;

                // Add price line series
                const priceSeries = chart.addLineSeries({
                    color: '#22d3ee',
                    lineWidth: 2,
                    priceLineVisible: false,
                    lastValueVisible: true
                });
                seriesRef.current.price = priceSeries;

                // Add bid line (dashed green)
                const bidSeries = chart.addLineSeries({
                    color: '#22c55e',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    priceLineVisible: false,
                    lastValueVisible: false
                });
                seriesRef.current.bid = bidSeries;

                // Add ask line (dashed red)
                const askSeries = chart.addLineSeries({
                    color: '#ef4444',
                    lineWidth: 1,
                    lineStyle: 2,
                    priceLineVisible: false,
                    lastValueVisible: false
                });
                seriesRef.current.ask = askSeries;

                // Register with sync manager
                if (syncManager) {
                    const adapter = {
                        setTimeRange: (fromMs, toMs) => {
                            if (chart) {
                                chart.timeScale().setVisibleRange({
                                    from: Math.floor(fromMs / 1000),
                                    to: Math.floor(toMs / 1000)
                                });
                            }
                        },
                        setCursor: (timestampMs) => {
                            // LWC doesn't have programmatic cursor positioning
                        },
                        clearCursor: () => {}
                    };
                    adapterRef.current = adapter;
                    syncManager.register('priceChart', 'lwc', chart, adapter);

                    // Subscribe to time range changes
                    chart.timeScale().subscribeVisibleTimeRangeChange((range) => {
                        if (range && !syncManager.isProgrammaticUpdate) {
                            syncManager.setTimeRange(range.from * 1000, range.to * 1000, 'priceChart');
                        }
                    });

                    // Subscribe to crosshair movements
                    chart.subscribeCrosshairMove((param) => {
                        if (param.time && !syncManager.isProgrammaticUpdate) {
                            syncManager.setCursor(param.time * 1000, 'priceChart');
                        } else if (!param.time) {
                            syncManager.clearCursor('priceChart');
                        }
                    });
                }

                return () => {
                    if (syncManager) {
                        syncManager.unregister('priceChart');
                    }
                    chart.remove();
                    chartRef.current = null;
                    seriesRef.current = {};
                    adapterRef.current = null;
                };
            }, [width, height, syncManager]);

            // Update data
            useEffect(() => {
                if (!seriesRef.current.price || !priceData?.length) return;

                // Transform and set price data
                const pricePoints = priceData.map(p => ({
                    time: Math.floor(p.timestamp_ms / 1000),
                    value: p.price
                })).sort((a, b) => a.time - b.time);

                // Remove duplicates
                const uniquePrice = pricePoints.filter((p, i, arr) =>
                    i === 0 || p.time !== arr[i-1].time
                );
                if (uniquePrice.length > 0) {
                    seriesRef.current.price.setData(uniquePrice);
                }

                // Build quote overlay data
                if (quoteData?.length && seriesRef.current.bid && seriesRef.current.ask) {
                    const quoteMap = new Map();
                    quoteData.forEach(q => {
                        quoteMap.set(Math.floor(q.timestamp_ms / 1000), q);
                    });

                    const bidPoints = [];
                    const askPoints = [];
                    uniquePrice.forEach(p => {
                        const q = quoteMap.get(p.time);
                        if (q?.bid_prices?.[0]) {
                            bidPoints.push({ time: p.time, value: q.bid_prices[0] });
                        }
                        if (q?.ask_prices?.[0]) {
                            askPoints.push({ time: p.time, value: q.ask_prices[0] });
                        }
                    });

                    if (bidPoints.length > 0) seriesRef.current.bid.setData(bidPoints);
                    if (askPoints.length > 0) seriesRef.current.ask.setData(askPoints);
                }

                // Fit content
                if (chartRef.current) {
                    chartRef.current.timeScale().fitContent();
                }
            }, [priceData, quoteData]);

            return e('div', { ref: containerRef, style: { width: '100%', height: height || 350 } });
        };

        // Custom Canvas 2D heatmap for order book with timestamp-based positioning
        const BookHeatMapCanvas = ({ data, width, height, syncManager }) => {
            const canvasRef = useRef(null);
            const overlayRef = useRef(null);
            const dataRef = useRef(data);
            const marginsRef = useRef({ top: 10, right: 10, bottom: 25, left: 50 });
            const dimensionsRef = useRef({ w: 0, h: 0, plotW: 0, plotH: 0 });

            // Update data ref
            useEffect(() => { dataRef.current = data; }, [data]);

            // Helper: convert timestamp to X position
            const timestampToX = useCallback((ts, plotW, margin) => {
                const d = dataRef.current;
                if (!d || d.length < 2) return null;
                const t0 = d[0].timestamp_ms;
                const tN = d[d.length - 1].timestamp_ms;
                const timeRange = tN - t0;
                if (timeRange <= 0) return null;
                return margin.left + ((ts - t0) / timeRange) * plotW;
            }, []);

            // Helper: convert X position to timestamp
            const xToTimestamp = useCallback((x, plotW, margin) => {
                const d = dataRef.current;
                if (!d || d.length < 2) return null;
                const t0 = d[0].timestamp_ms;
                const tN = d[d.length - 1].timestamp_ms;
                const ratio = (x - margin.left) / plotW;
                return t0 + ratio * (tN - t0);
            }, []);

            // Draw cursor line on overlay
            const drawCursor = useCallback((x) => {
                const overlay = overlayRef.current;
                if (!overlay) return;
                const ctx = overlay.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const { w, h, plotH } = dimensionsRef.current;
                const margin = marginsRef.current;

                ctx.clearRect(0, 0, w * dpr, h * dpr);
                if (x !== null && x >= margin.left && x <= w - margin.right) {
                    ctx.save();
                    ctx.scale(dpr, dpr);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + plotH);
                    ctx.stroke();
                    ctx.restore();
                }
            }, []);

            // Main drawing effect
            useEffect(() => {
                const canvas = canvasRef.current;
                const overlay = overlayRef.current;
                if (!canvas || !overlay || !data?.length) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const w = width || canvas.parentElement?.offsetWidth || 400;
                const h = height || 350;

                // Set up both canvases
                [canvas, overlay].forEach(c => {
                    c.width = w * dpr;
                    c.height = h * dpr;
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                });
                ctx.scale(dpr, dpr);

                // Calculate bounds
                const allPrices = data.flatMap(d => [...d.bids.map(b => b.price), ...d.asks.map(a => a.price)]);
                if (allPrices.length === 0) return;

                const minPrice = Math.min(...allPrices);
                const maxPrice = Math.max(...allPrices);
                const priceRange = maxPrice - minPrice || 1;

                const maxSize = Math.max(...data.flatMap(d =>
                    [...d.bids.map(b => b.size), ...d.asks.map(a => a.size)]
                )) || 1;

                // Margins and dimensions
                const margin = marginsRef.current;
                const plotW = w - margin.left - margin.right;
                const plotH = h - margin.top - margin.bottom;
                dimensionsRef.current = { w, h, plotW, plotH };

                // Time range for timestamp-based positioning
                const t0 = data[0].timestamp_ms;
                const tN = data[data.length - 1].timestamp_ms;
                const timeRange = tN - t0 || 1;
                const cellW = Math.max(1, plotW / data.length);

                // Clear
                ctx.fillStyle = '#12121a';
                ctx.fillRect(0, 0, w, h);

                // Draw cells using TIMESTAMP-BASED positioning
                data.forEach((snapshot) => {
                    const x = margin.left + ((snapshot.timestamp_ms - t0) / timeRange) * plotW;

                    // Bids (green)
                    snapshot.bids.forEach(level => {
                        const y = margin.top + ((maxPrice - level.price) / priceRange) * plotH;
                        const intensity = Math.min(1, level.size / maxSize);
                        ctx.fillStyle = `rgba(34, 197, 94, ${0.15 + intensity * 0.85})`;
                        ctx.fillRect(x, y - 1.5, cellW + 0.5, 3);
                    });

                    // Asks (red)
                    snapshot.asks.forEach(level => {
                        const y = margin.top + ((maxPrice - level.price) / priceRange) * plotH;
                        const intensity = Math.min(1, level.size / maxSize);
                        ctx.fillStyle = `rgba(239, 68, 68, ${0.15 + intensity * 0.85})`;
                        ctx.fillRect(x, y - 1.5, cellW + 0.5, 3);
                    });
                });

                // Y axis labels (prices)
                ctx.fillStyle = '#71717a';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                const priceSteps = 5;
                for (let i = 0; i <= priceSteps; i++) {
                    const price = maxPrice - (i / priceSteps) * priceRange;
                    const y = margin.top + (i / priceSteps) * plotH;
                    ctx.fillText(price.toFixed(0), margin.left - 5, y + 3);
                }

                // X axis labels (time) - also timestamp-based
                ctx.textAlign = 'center';
                const timeSteps = Math.min(6, data.length);
                for (let i = 0; i < timeSteps; i++) {
                    const ts = t0 + (i / (timeSteps - 1)) * timeRange;
                    const x = margin.left + (i / (timeSteps - 1)) * plotW;
                    // Find closest data point for label
                    const closest = data.reduce((prev, curr) =>
                        Math.abs(curr.timestamp_ms - ts) < Math.abs(prev.timestamp_ms - ts) ? curr : prev
                    );
                    ctx.fillText(closest?.time || '', x, h - 5);
                }

            }, [data, width, height]);

            // Register with sync manager
            useEffect(() => {
                if (!syncManager) return;

                const adapter = {
                    setTimeRange: (fromMs, toMs) => {
                        // Canvas charts could filter data here for zoom
                    },
                    setCursor: (timestampMs) => {
                        const { plotW } = dimensionsRef.current;
                        const margin = marginsRef.current;
                        const x = timestampToX(timestampMs, plotW, margin);
                        drawCursor(x);
                    },
                    clearCursor: () => {
                        drawCursor(null);
                    }
                };
                syncManager.register('bookHeatmap', 'canvas', canvasRef.current, adapter);

                return () => {
                    syncManager.unregister('bookHeatmap');
                };
            }, [syncManager, timestampToX, drawCursor]);

            // Mouse event handlers
            const handleMouseMove = useCallback((e) => {
                if (!syncManager) return;
                const canvas = canvasRef.current;
                if (!canvas) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const { plotW } = dimensionsRef.current;
                const margin = marginsRef.current;

                if (x >= margin.left && x <= margin.left + plotW) {
                    const ts = xToTimestamp(x, plotW, margin);
                    if (ts) {
                        syncManager.setCursor(ts, 'bookHeatmap');
                        drawCursor(x);
                    }
                }
            }, [syncManager, xToTimestamp, drawCursor]);

            const handleMouseLeave = useCallback(() => {
                if (syncManager) {
                    syncManager.clearCursor('bookHeatmap');
                }
                drawCursor(null);
            }, [syncManager, drawCursor]);

            return e('div', { style: { position: 'relative', width: '100%', height: height || 300 } },
                e('canvas', {
                    ref: canvasRef,
                    style: { width: '100%', height: '100%', display: 'block' },
                    onMouseMove: handleMouseMove,
                    onMouseLeave: handleMouseLeave
                }),
                e('canvas', {
                    ref: overlayRef,
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none'
                    }
                })
            );
        };

        // Colors
        const C = {
            bg: '#0a0a0f',
            bgCard: '#12121a',
            border: '#2a2a3a',
            text: '#e4e4e7',
            textMuted: '#71717a',
            textDim: '#52525b',
            accent: '#22d3ee',
            green: '#22c55e',
            red: '#ef4444',
            yellow: '#eab308',
            purple: '#a855f7',
            orange: '#f97316',
            regimeQuiet: '#22c55e',
            regimeTrending: '#3b82f6',
            regimeVolatile: '#f97316',
            regimeCascade: '#ef4444',
        };

        // API Configuration
        const API_BASE = 'http://localhost:8080';  // Change to your market maker's metrics port
        const WS_URL = 'ws://localhost:8080/ws/dashboard';  // WebSocket endpoint

        // WebSocket Dashboard Client
        class DashboardWebSocket {
            constructor(url, onSnapshot, onUpdate, onFill, onConnected, onDisconnected) {
                this.url = url;
                this.onSnapshot = onSnapshot;
                this.onUpdate = onUpdate;
                this.onFill = onFill;
                this.onConnected = onConnected;
                this.onDisconnected = onDisconnected;
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectDelay = 5000;
                this.connected = false;
            }

            connect() {
                try {
                    this.ws = new WebSocket(this.url);

                    this.ws.onopen = () => {
                        console.log('[WS] Connected to dashboard');
                        this.connected = true;
                        this.reconnectAttempts = 0;
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const msg = JSON.parse(event.data);
                            switch (msg.type) {
                                case 'snapshot':
                                    this.onSnapshot(msg.state);
                                    break;
                                case 'update':
                                    this.onUpdate(msg);
                                    break;
                                case 'fill':
                                    this.onFill(msg.record);
                                    break;
                                case 'connected':
                                    console.log('[WS] Client ID:', msg.client_id);
                                    this.onConnected();
                                    break;
                            }
                        } catch (e) {
                            console.error('[WS] Failed to parse message:', e);
                        }
                    };

                    this.ws.onclose = () => {
                        console.log('[WS] Disconnected');
                        this.connected = false;
                        this.onDisconnected();
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('[WS] Error:', error);
                        this.connected = false;
                    };
                } catch (e) {
                    console.error('[WS] Failed to connect:', e);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts), this.maxReconnectDelay);
                this.reconnectAttempts++;
                console.log(`[WS] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                setTimeout(() => this.connect(), delay);
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Default data for when API is unavailable
        const defaultQuotes = {
            mid: '0.00',
            spreadBps: '0.0',
            inventory: '0.000',
            regime: 'Unknown',
            kappa: '0',
            gamma: '0.000',
            fillProb: '0.0',
            asProb: '0.0',
        };

        const defaultPnL = {
            spreadCapture: 0,
            adverseSelection: 0,
            inventoryCost: 0,
            fees: 0,
        };

        const defaultCalib = {
            brier: 0,
            ir: 0,
            curve: []
        };

        // Helper to generate lead-lag data (static, doesn't come from API)
        const genLeadLag = () => Array.from({length: 40}, (_, i) => {
            const lag = -200 + i * 20;
            const peak = 150;
            return {
                lag,
                r2: Math.max(0, 0.35 * Math.exp(-Math.pow(lag - peak, 2) / 20000) + Math.random() * 0.03)
            };
        });

        // API fetch function
        const fetchDashboard = async () => {
            try {
                const response = await fetch(API_BASE + '/api/dashboard');
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                return { data, connected: true };
            } catch (err) {
                console.error('Failed to fetch dashboard data:', err);
                return { data: null, connected: false };
            }
        };

        // Transform API data to component format
        const transformQuotes = (data) => ({
            mid: data.quotes.mid.toFixed(1),
            spreadBps: data.quotes.spread_bps.toFixed(1),
            inventory: data.quotes.inventory.toFixed(3),
            regime: data.quotes.regime,
            kappa: data.quotes.kappa.toFixed(0),
            gamma: data.quotes.gamma.toFixed(3),
            fillProb: data.quotes.fill_prob.toFixed(1),
            asProb: data.quotes.adverse_prob.toFixed(1),
        });

        const transformPnL = (data) => ({
            spreadCapture: data.pnl.spread_capture,
            adverseSelection: data.pnl.adverse_selection,
            inventoryCost: data.pnl.inventory_cost,
            fees: data.pnl.fees,
        });

        const transformRegimeHistory = (data) => {
            if (!data.regime.history || data.regime.history.length === 0) {
                return [];
            }
            return data.regime.history.map(h => ({
                time: h.time,
                timestamp_ms: h.timestamp_ms,
                Quiet: h.Quiet,
                Trending: h.Trending,
                Volatile: h.Volatile,
                Cascade: h.Cascade,
            }));
        };

        const transformFills = (data) => {
            if (!data.fills || data.fills.length === 0) {
                return [];
            }
            return data.fills.map(f => ({
                time: f.time,
                timestamp_ms: f.timestamp_ms,
                pnl: f.pnl,
                cumPnl: f.cum_pnl,
                side: f.side,
                as: f.adverse_selection
            }));
        };

        const transformCalibration = (calib) => {
            if (!calib || !calib.calibration_curve) {
                return [];
            }
            return calib.calibration_curve.map(bin => ({
                predicted: bin.predicted,
                realized: bin.realized,
                perfect: bin.predicted
            }));
        };

        const transformSignals = (data) => {
            if (!data.signals || data.signals.length === 0) {
                return [
                    { signal: 'binance_lead', mi: 0.089, corr: 0.31, lag: -150, rv: 2.3 },
                    { signal: 'trade_imb_1s', mi: 0.067, corr: 0.24, lag: 0, rv: 1.2 },
                    { signal: 'microprice_imb', mi: 0.045, corr: 0.19, lag: 0, rv: 0.8 },
                    { signal: 'funding_x_imb', mi: 0.041, corr: 0.15, lag: 0, rv: 3.1 },
                    { signal: 'oi_change_1m', mi: 0.023, corr: 0.08, lag: 0, rv: 0.6 },
                ];
            }
            return data.signals.map(s => ({
                signal: s.signal,
                mi: s.mi,
                corr: s.corr,
                lag: s.lag,
                rv: s.rv
            }));
        };

        // Components
        const Card = ({title, subtitle, accent, children}) => 
            e('div', {
                className: 'rounded-lg border overflow-hidden relative',
                style: {backgroundColor: C.bgCard, borderColor: C.border}
            },
                accent && e('div', {className: 'absolute top-0 left-0 right-0 h-0.5', style: {backgroundColor: accent}}),
                title && e('div', {className: 'px-4 py-3 border-b', style: {borderColor: C.border}},
                    e('h3', {className: 'text-sm font-medium tracking-wide uppercase mono', style: {color: C.text}}, title),
                    subtitle && e('p', {className: 'text-xs mt-0.5', style: {color: C.textMuted}}, subtitle)
                ),
                e('div', {className: 'p-4'}, children)
            );

        const Metric = ({label, value, unit}) =>
            e('div', {className: 'flex flex-col'},
                e('span', {className: 'text-xs uppercase tracking-wider mb-1 mono', style: {color: C.textMuted}}, label),
                e('div', {className: 'flex items-baseline gap-1'},
                    e('span', {className: 'text-2xl font-bold tabular-nums mono', style: {color: C.text}}, value),
                    unit && e('span', {className: 'text-sm', style: {color: C.textMuted}}, unit)
                )
            );

        const RegimeBadge = ({regime}) => {
            const colors = {Quiet: C.regimeQuiet, Trending: C.regimeTrending, Volatile: C.regimeVolatile, Cascade: C.regimeCascade};
            return e('span', {
                className: 'px-2 py-0.5 rounded text-xs font-medium uppercase tracking-wider mono',
                style: {backgroundColor: colors[regime] + '20', color: colors[regime]}
            }, regime);
        };

        const Tab = ({id, label, active, onClick}) =>
            e('button', {
                onClick: () => onClick(id),
                className: 'px-4 py-2 rounded text-xs uppercase tracking-wider transition-all whitespace-nowrap mono',
                style: {
                    backgroundColor: active ? C.accent + '20' : 'transparent',
                    color: active ? C.accent : C.textMuted,
                    border: `1px solid ${active ? C.accent + '40' : 'transparent'}`
                }
            }, label);

        // ============================================================================
        // CHART COMPONENTS (Canvas-based via uPlot)
        // ============================================================================

        // Regime probabilities stacked area chart
        const RegimeChart = ({data, syncManager}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for regime data...');
            }

            // Transform to uPlot columnar format with stacking
            // Use timestamp_ms for x-axis (converted to seconds for uPlot time mode)
            const timestamps = data.map(d => d.timestamp_ms ? d.timestamp_ms / 1000 : 0);
            const quiet = data.map(d => d.Quiet || 0);
            const trending = data.map(d => (d.Quiet || 0) + (d.Trending || 0));
            const volatile = data.map(d => (d.Quiet || 0) + (d.Trending || 0) + (d.Volatile || 0));
            const cascade = data.map(d => (d.Quiet || 0) + (d.Trending || 0) + (d.Volatile || 0) + (d.Cascade || 0));

            const uData = [timestamps, quiet, trending, volatile, cascade];

            const opts = {
                scales: { x: { time: true }, y: { range: [0, 1] } },
                axes: [
                    { ...uPlotDarkTheme.axes[0] },
                    { ...uPlotDarkTheme.axes[1], values: (u, vals) => vals.map(v => (v * 100).toFixed(0) + '%') }
                ],
                series: [
                    {},
                    { label: 'Quiet', stroke: C.regimeQuiet, fill: C.regimeQuiet + '99', width: 1 },
                    { label: 'Trending', stroke: C.regimeTrending, fill: null, width: 1 },
                    { label: 'Volatile', stroke: C.regimeVolatile, fill: null, width: 1 },
                    { label: 'Cascade', stroke: C.regimeCascade, fill: null, width: 1 }
                ],
                bands: [
                    { series: [4, 3], fill: C.regimeCascade + '99' },
                    { series: [3, 2], fill: C.regimeVolatile + '99' },
                    { series: [2, 1], fill: C.regimeTrending + '99' },
                ]
            };

            return e(UPlotChart, { data: uData, options: opts, height: 200 });
        };

        // Cumulative PnL area chart
        const PnLChart = ({data, syncManager}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for fill data...');
            }

            // Use timestamp_ms for x-axis (converted to seconds for uPlot time mode)
            const timestamps = data.map(d => d.timestamp_ms ? d.timestamp_ms / 1000 : 0);
            const pnlValues = data.map(d => d.cumPnl || 0);

            const uData = [timestamps, pnlValues];

            const opts = {
                scales: { x: { time: true } },
                axes: [
                    { ...uPlotDarkTheme.axes[0] },
                    { ...uPlotDarkTheme.axes[1], values: (u, vals) => vals.map(v => '$' + (v || 0).toFixed(0)) }
                ],
                series: [
                    {},
                    { label: 'Cumulative PnL', stroke: C.accent, fill: C.accent + '33', width: 2 }
                ]
            };

            return e(UPlotChart, { data: uData, options: opts, height: 200 });
        };

        // PnL waterfall bar chart (Canvas)
        const WaterfallChart = ({data}) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.parentElement?.offsetWidth || 400;
                const h = 200;

                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.scale(dpr, dpr);

                const items = [
                    { name: 'Spread', value: data?.spreadCapture || 0, color: C.green },
                    { name: 'Adverse', value: data?.adverseSelection || 0, color: C.red },
                    { name: 'Inventory', value: data?.inventoryCost || 0, color: C.orange },
                    { name: 'Fees', value: data?.fees || 0, color: C.purple }
                ];

                const margin = { top: 20, right: 20, bottom: 30, left: 50 };
                const plotW = w - margin.left - margin.right;
                const plotH = h - margin.top - margin.bottom;
                const barW = plotW / items.length * 0.6;
                const gap = plotW / items.length;

                // Find range
                const maxVal = Math.max(...items.map(i => Math.abs(i.value)), 1);

                // Clear
                ctx.fillStyle = '#12121a';
                ctx.fillRect(0, 0, w, h);

                // Draw zero line
                const zeroY = margin.top + plotH / 2;
                ctx.strokeStyle = C.textDim;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(margin.left, zeroY);
                ctx.lineTo(w - margin.right, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw bars
                items.forEach((item, i) => {
                    const x = margin.left + i * gap + (gap - barW) / 2;
                    const barH = (item.value / maxVal) * (plotH / 2);
                    const y = item.value >= 0 ? zeroY - barH : zeroY;

                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barW, Math.abs(barH), [4, 4, 0, 0]);
                    ctx.fill();

                    // Label
                    ctx.fillStyle = C.textMuted;
                    ctx.font = '9px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.name, x + barW / 2, h - 8);

                    // Value
                    ctx.fillStyle = C.text;
                    ctx.fillText('$' + item.value.toFixed(0), x + barW / 2, item.value >= 0 ? y - 5 : y + Math.abs(barH) + 12);
                });

                // Y axis labels
                ctx.fillStyle = C.textMuted;
                ctx.textAlign = 'right';
                ctx.fillText('$' + maxVal.toFixed(0), margin.left - 5, margin.top + 10);
                ctx.fillText('$0', margin.left - 5, zeroY + 3);
                ctx.fillText('-$' + maxVal.toFixed(0), margin.left - 5, h - margin.bottom - 5);

            }, [data]);

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 200, display: 'block' } });
        };

        // Lead-lag area chart
        const LeadLagChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...');
            }

            const lags = data.map(d => d.lag);
            const r2Values = data.map(d => d.r2 || 0);
            const uData = [lags, r2Values];

            const opts = {
                scales: { x: { time: false } },
                axes: [
                    { ...uPlotDarkTheme.axes[0], values: (u, vals) => vals.map(v => v + 'ms') },
                    { ...uPlotDarkTheme.axes[1], values: (u, vals) => vals.map(v => (v || 0).toFixed(2)) }
                ],
                series: [
                    {},
                    { label: 'R²', stroke: C.purple, fill: C.purple + '4D', width: 2 }
                ]
            };

            return e(UPlotChart, { data: uData, options: opts, height: 200 });
        };

        // Signal Time Series Chart (NEW) - shows kappa, momentum, flow imbalance over time
        const SignalTimeSeriesChart = ({data, field, label, color}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-32 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for signal data...');
            }

            const times = data.map(d => d.timestamp_ms / 1000);
            const values = data.map(d => d[field] || 0);
            const uData = [times, values];

            const opts = {
                scales: { x: { time: true } },
                axes: [
                    { ...uPlotDarkTheme.axes[0], values: (u, vals) => vals.map(v => new Date(v * 1000).toLocaleTimeString()) },
                    { ...uPlotDarkTheme.axes[1], values: (u, vals) => vals.map(v => v.toFixed(2)) }
                ],
                series: [
                    {},
                    { label: label, stroke: color, fill: color + '33', width: 2 }
                ]
            };

            return e(UPlotChart, { data: uData, options: opts, height: 120 });
        };

        // Multi-signal chart showing kappa with confidence bands
        const KappaChart = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-40 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for kappa data...');
            }

            const times = data.map(d => d.timestamp_ms / 1000);
            const kappa = data.map(d => d.kappa || 0);
            const ciLower = data.map(d => d.kappa_ci_lower || d.kappa * 0.7);
            const ciUpper = data.map(d => d.kappa_ci_upper || d.kappa * 1.3);
            const uData = [times, kappa, ciLower, ciUpper];

            const opts = {
                scales: { x: { time: true } },
                axes: [
                    { ...uPlotDarkTheme.axes[0], values: (u, vals) => vals.map(v => new Date(v * 1000).toLocaleTimeString().slice(0, 5)) },
                    { ...uPlotDarkTheme.axes[1], values: (u, vals) => vals.map(v => v.toFixed(0)) }
                ],
                series: [
                    {},
                    { label: 'κ', stroke: C.accent, width: 2 },
                    { label: '95% CI Low', stroke: C.accent + '66', width: 1, dash: [4, 4] },
                    { label: '95% CI High', stroke: C.accent + '66', width: 1, dash: [4, 4] }
                ]
            };

            return e(UPlotChart, { data: uData, options: opts, height: 160 });
        };

        // Quote Decision Log Table
        const DecisionLogTable = ({data}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-32 flex items-center justify-center', style: {color: C.textMuted}}, 'No decisions yet...');
            }

            // Show last 15 decisions, newest first
            const recent = [...data].reverse().slice(0, 15);

            return e('div', {className: 'overflow-x-auto'},
                e('table', {className: 'w-full text-xs'},
                    e('thead', null,
                        e('tr', {style: {borderBottom: '1px solid ' + C.border}},
                            e('th', {className: 'text-left py-2 px-1', style: {color: C.textMuted}}, 'Time'),
                            e('th', {className: 'text-right py-2 px-1', style: {color: C.textMuted}}, 'Bid'),
                            e('th', {className: 'text-right py-2 px-1', style: {color: C.textMuted}}, 'Ask'),
                            e('th', {className: 'text-right py-2 px-1', style: {color: C.textMuted}}, 'κ'),
                            e('th', {className: 'text-right py-2 px-1', style: {color: C.textMuted}}, 'γ'),
                            e('th', {className: 'text-right py-2 px-1', style: {color: C.textMuted}}, 'σ'),
                            e('th', {className: 'text-center py-2 px-1', style: {color: C.textMuted}}, 'Regime'),
                            e('th', {className: 'text-left py-2 px-1', style: {color: C.textMuted}}, 'Reason')
                        )
                    ),
                    e('tbody', null,
                        recent.map((d, i) =>
                            e('tr', {key: i, style: {borderBottom: '1px solid ' + C.border + '44'}},
                                e('td', {className: 'py-1.5 px-1 mono', style: {color: C.textMuted}}, d.time),
                                e('td', {className: 'text-right py-1.5 px-1 mono', style: {color: C.green}}, d.bid_spread_bps.toFixed(1)),
                                e('td', {className: 'text-right py-1.5 px-1 mono', style: {color: C.red}}, d.ask_spread_bps.toFixed(1)),
                                e('td', {className: 'text-right py-1.5 px-1 mono', style: {color: C.accent}}, d.input_kappa.toFixed(0)),
                                e('td', {className: 'text-right py-1.5 px-1 mono', style: {color: C.text}}, d.input_gamma.toFixed(2)),
                                e('td', {className: 'text-right py-1.5 px-1 mono', style: {color: C.text}}, (d.input_sigma * 10000).toFixed(1)),
                                e('td', {className: 'text-center py-1.5 px-1'},
                                    e('span', {
                                        className: 'px-1.5 py-0.5 rounded text-xs',
                                        style: {
                                            backgroundColor: d.regime === 'Cascade' ? C.red + '33' :
                                                           d.regime === 'Volatile' ? C.orange + '33' :
                                                           d.regime === 'Trending' ? C.blue + '33' : C.green + '33',
                                            color: d.regime === 'Cascade' ? C.red :
                                                  d.regime === 'Volatile' ? C.orange :
                                                  d.regime === 'Trending' ? C.blue : C.green
                                        }
                                    }, d.regime)
                                ),
                                e('td', {className: 'py-1.5 px-1 text-xs', style: {color: d.defensive_reason ? C.orange : C.textMuted}},
                                    d.defensive_reason || '—')
                            )
                        )
                    )
                )
            );
        };

        // Kappa Diagnostics Panel
        const KappaDiagPanel = ({diag}) => {
            return e('div', {className: 'space-y-3'},
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Posterior Mean'),
                    e('span', {className: 'mono text-sm', style: {color: C.accent}}, diag.posterior_mean.toFixed(0))
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Std Dev'),
                    e('span', {className: 'mono text-sm', style: {color: C.text}}, '±' + diag.posterior_std.toFixed(0))
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Confidence'),
                    e('span', {className: 'mono text-sm', style: {color: diag.confidence > 0.7 ? C.green : C.orange}},
                        (diag.confidence * 100).toFixed(0) + '%')
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, '95% CI'),
                    e('span', {className: 'mono text-sm', style: {color: C.text}},
                        '[' + diag.ci_95_lower.toFixed(0) + ', ' + diag.ci_95_upper.toFixed(0) + ']')
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Observations'),
                    e('span', {className: 'mono text-sm', style: {color: C.text}}, diag.observation_count)
                )
            );
        };

        // Changepoint Diagnostics Panel
        const ChangepointDiagPanel = ({diag}) => {
            return e('div', {className: 'space-y-3'},
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'CP Prob (5)'),
                    e('span', {className: 'mono text-sm', style: {color: diag.cp_prob_5 > 0.3 ? C.orange : C.green}},
                        (diag.cp_prob_5 * 100).toFixed(1) + '%')
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Run Length'),
                    e('span', {className: 'mono text-sm', style: {color: C.text}}, diag.run_length + ' obs')
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Entropy'),
                    e('span', {className: 'mono text-sm', style: {color: C.text}}, diag.entropy.toFixed(2) + ' bits')
                ),
                e('div', {className: 'flex justify-between'},
                    e('span', {className: 'text-xs', style: {color: C.textMuted}}, 'Detected'),
                    e('span', {
                        className: 'px-2 py-0.5 rounded text-xs',
                        style: {
                            backgroundColor: diag.detected ? C.red + '33' : C.green + '33',
                            color: diag.detected ? C.red : C.green
                        }
                    }, diag.detected ? 'YES' : 'NO')
                )
            );
        };

        // Calibration scatter + line chart (Canvas)
        const CalibrationChart = ({data}) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data?.length) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.parentElement?.offsetWidth || 400;
                const h = 250;

                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.scale(dpr, dpr);

                const margin = { top: 20, right: 20, bottom: 30, left: 40 };
                const plotW = w - margin.left - margin.right;
                const plotH = h - margin.top - margin.bottom;

                // Clear
                ctx.fillStyle = '#12121a';
                ctx.fillRect(0, 0, w, h);

                // Draw grid
                ctx.strokeStyle = C.border;
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = margin.top + (i / 5) * plotH;
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(w - margin.right, y);
                    ctx.stroke();
                }

                // Draw perfect calibration line (dashed diagonal)
                ctx.strokeStyle = C.textDim;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(margin.left, h - margin.bottom);
                ctx.lineTo(w - margin.right, margin.top);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw scatter points
                ctx.fillStyle = C.accent;
                data.forEach(d => {
                    const x = margin.left + (d.predicted || 0) * plotW;
                    const y = margin.top + (1 - (d.realized || 0)) * plotH;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Axis labels
                ctx.fillStyle = C.textMuted;
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText('Predicted', w / 2, h - 5);
                ctx.save();
                ctx.translate(10, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Realized', 0, 0);
                ctx.restore();

            }, [data]);

            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for calibration data...');
            }

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 250, display: 'block' } });
        };

        const SignalTable = ({data}) =>
            e('table', {className: 'w-full text-xs mono'},
                e('thead', null,
                    e('tr', {style: {borderBottom: `1px solid ${C.border}`}},
                        e('th', {className: 'text-left py-2 px-2', style: {color: C.textMuted}}, 'SIGNAL'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'MI'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'CORR'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'LAG'),
                        e('th', {className: 'text-right py-2 px-2', style: {color: C.textMuted}}, 'VAR')
                    )
                ),
                e('tbody', null,
                    data.map((row, i) =>
                        e('tr', {key: i, style: {borderBottom: `1px solid ${C.border}`, backgroundColor: i % 2 ? C.bgCard : 'transparent'}},
                            e('td', {className: 'py-2 px-2', style: {color: C.text}}, row.signal),
                            e('td', {className: 'text-right py-2 px-2', style: {color: C.accent}}, row.mi.toFixed(3)),
                            e('td', {className: 'text-right py-2 px-2', style: {color: C.text}}, row.corr.toFixed(2)),
                            e('td', {className: 'text-right py-2 px-2', style: {color: row.lag !== 0 ? C.yellow : C.textMuted}}, row.lag + 'ms'),
                            e('td', {className: 'text-right py-2 px-2', style: {color: row.rv > 2 ? C.orange : C.textMuted}}, row.rv.toFixed(1) + 'x')
                        )
                    )
                )
            );

        // ============================================================================
        // NEW VISUALIZATION COMPONENTS (Canvas-based)
        // ============================================================================

        // 2D Order Book Heat Map - uses Canvas for performance
        const BookHeatMap = ({data, quoteData, syncManager}) => {
            if (!data || data.length === 0) {
                return e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for order book data...');
            }
            return e(BookHeatMapCanvas, { data, height: 350, syncManager });
        };

        // Live Mid Price Chart with Quote Overlay - uses lightweight-charts
        const PriceChart = ({priceData, quoteData, syncManager}) => {
            if (!priceData || priceData.length === 0) {
                return e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for price data...');
            }
            return e(LWCPriceChart, { priceData, quoteData, height: 350, syncManager });
        };

        // Spread Distribution Histogram (Canvas)
        const SpreadHistogram = ({data}) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data?.length) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.parentElement?.offsetWidth || 400;
                const h = 200;

                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.scale(dpr, dpr);

                const margin = { top: 20, right: 20, bottom: 35, left: 40 };
                const plotW = w - margin.left - margin.right;
                const plotH = h - margin.top - margin.bottom;
                const barW = plotW / data.length * 0.7;
                const gap = plotW / data.length;

                const maxCount = Math.max(...data.map(d => d.count || 0), 1);

                // Clear
                ctx.fillStyle = '#12121a';
                ctx.fillRect(0, 0, w, h);

                // Draw bars
                data.forEach((item, i) => {
                    const x = margin.left + i * gap + (gap - barW) / 2;
                    const barH = ((item.count || 0) / maxCount) * plotH;
                    const y = margin.top + plotH - barH;

                    ctx.fillStyle = C.purple;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barW, barH, [4, 4, 0, 0]);
                    ctx.fill();

                    // X label
                    ctx.fillStyle = C.textMuted;
                    ctx.font = '9px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.range_bps || '', x + barW / 2, h - 8);
                });

                // Y axis
                ctx.fillStyle = C.textMuted;
                ctx.textAlign = 'right';
                ctx.fillText(maxCount.toFixed(0), margin.left - 5, margin.top + 10);
                ctx.fillText('0', margin.left - 5, h - margin.bottom);

                // X axis label
                ctx.textAlign = 'center';
                ctx.fillText('Spread (bps)', w / 2, h - 20);

            }, [data]);

            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for spread data...');
            }

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 200, display: 'block' } });
        };

        // Quote Fill Rate by Level (Canvas horizontal bar)
        const FillRateChart = ({data}) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data?.length) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const w = canvas.parentElement?.offsetWidth || 400;
                const h = 200;

                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.scale(dpr, dpr);

                // Group by level
                const byLevel = {};
                data.forEach(d => {
                    if (!byLevel[d.level]) byLevel[d.level] = { level: d.level, bid: 0, ask: 0 };
                    if (d.side === 'BID') byLevel[d.level].bid = d.fill_count;
                    else byLevel[d.level].ask = d.fill_count;
                });
                const chartData = Object.values(byLevel).sort((a, b) => a.level - b.level);
                if (chartData.length === 0) return;

                const margin = { top: 20, right: 20, bottom: 20, left: 35 };
                const plotW = w - margin.left - margin.right;
                const plotH = h - margin.top - margin.bottom;
                const barH = plotH / chartData.length * 0.35;
                const rowH = plotH / chartData.length;

                const maxVal = Math.max(...chartData.flatMap(d => [d.bid, d.ask]), 1);

                // Clear
                ctx.fillStyle = '#12121a';
                ctx.fillRect(0, 0, w, h);

                // Draw bars
                chartData.forEach((item, i) => {
                    const y = margin.top + i * rowH;

                    // Bid bar (green)
                    const bidW = (item.bid / maxVal) * plotW;
                    ctx.fillStyle = C.green;
                    ctx.fillRect(margin.left, y + rowH * 0.15, bidW, barH);

                    // Ask bar (red)
                    const askW = (item.ask / maxVal) * plotW;
                    ctx.fillStyle = C.red;
                    ctx.fillRect(margin.left, y + rowH * 0.5, askW, barH);

                    // Y label
                    ctx.fillStyle = C.textMuted;
                    ctx.font = '9px JetBrains Mono';
                    ctx.textAlign = 'right';
                    ctx.fillText('L' + item.level, margin.left - 5, y + rowH * 0.5);
                });

            }, [data]);

            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for fill data...');
            }

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 200, display: 'block' } });
        };

        // Current Book Depth (snapshot) - Canvas-based
        const DepthChart = ({data}) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current || !data || data.length === 0) return;
                const latest = data[data.length - 1];
                if (!latest) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                const W = rect.width, H = rect.height;

                // Build cumulative depth
                let bidCum = 0, askCum = 0;
                const bidDepth = latest.bids.map(b => { bidCum += b.size; return {price: b.price, cumSize: bidCum}; }).reverse();
                const askDepth = latest.asks.map(a => { askCum += a.size; return {price: a.price, cumSize: askCum}; });

                // Find ranges
                const allPrices = [...bidDepth.map(d => d.price), ...askDepth.map(d => d.price)];
                const allSizes = [...bidDepth.map(d => d.cumSize), ...askDepth.map(d => d.cumSize)];
                const minPrice = Math.min(...allPrices);
                const maxPrice = Math.max(...allPrices);
                const maxSize = Math.max(...allSizes);
                const priceRange = maxPrice - minPrice || 1;

                const margin = { top: 10, right: 10, bottom: 25, left: 50 };
                const plotW = W - margin.left - margin.right;
                const plotH = H - margin.top - margin.bottom;

                const priceToX = p => margin.left + ((p - minPrice) / priceRange) * plotW;
                const sizeToY = s => margin.top + plotH - (s / maxSize) * plotH;

                // Clear
                ctx.fillStyle = C.bgCard;
                ctx.fillRect(0, 0, W, H);

                // Grid
                ctx.strokeStyle = C.border;
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = margin.top + (plotH / 4) * i;
                    ctx.beginPath(); ctx.moveTo(margin.left, y); ctx.lineTo(W - margin.right, y); ctx.stroke();
                }

                // Draw bid depth (green, filled step)
                if (bidDepth.length > 0) {
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                    ctx.strokeStyle = C.profit;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(priceToX(bidDepth[0].price), sizeToY(0));
                    bidDepth.forEach((d, i) => {
                        ctx.lineTo(priceToX(d.price), sizeToY(d.cumSize));
                        if (i < bidDepth.length - 1) ctx.lineTo(priceToX(bidDepth[i + 1].price), sizeToY(d.cumSize));
                    });
                    ctx.lineTo(priceToX(bidDepth[bidDepth.length - 1].price), sizeToY(0));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw ask depth (red, filled step)
                if (askDepth.length > 0) {
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                    ctx.strokeStyle = C.loss;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(priceToX(askDepth[0].price), sizeToY(0));
                    askDepth.forEach((d, i) => {
                        ctx.lineTo(priceToX(d.price), sizeToY(d.cumSize));
                        if (i < askDepth.length - 1) ctx.lineTo(priceToX(askDepth[i + 1].price), sizeToY(d.cumSize));
                    });
                    ctx.lineTo(priceToX(askDepth[askDepth.length - 1].price), sizeToY(0));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                // Y axis labels
                ctx.fillStyle = C.textMuted;
                ctx.font = '10px monospace';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const size = (maxSize / 4) * (4 - i);
                    ctx.fillText(size.toFixed(2), margin.left - 5, margin.top + (plotH / 4) * i + 4);
                }

                // X axis labels
                ctx.textAlign = 'center';
                for (let i = 0; i <= 4; i++) {
                    const price = minPrice + (priceRange / 4) * i;
                    ctx.fillText(price.toFixed(0), margin.left + (plotW / 4) * i, H - 5);
                }

            }, [data]);

            if (!data || data.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for book data...');
            }

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 200, display: 'block' } });
        };

        // ============================================================================
        // FEATURE HEALTH COMPONENTS
        // ============================================================================

        // Signal Health Bar Chart
        const SignalHealthChart = ({ signals }) => {
            if (!signals || signals.length === 0) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'No signal data available');
            }

            const maxMi = Math.max(...signals.map(s => s.mi), 0.05);

            return e('div', {className: 'space-y-3'},
                signals.map((signal, i) => {
                    const statusColor = signal.status === 'healthy' ? C.green : signal.status === 'warning' ? C.yellow : C.red;
                    const trendIcon = signal.trend === 'up' ? '↑' : signal.trend === 'down' ? '↓' : '→';
                    const barWidth = (signal.mi / maxMi) * 100;

                    return e('div', {key: i, className: 'flex items-center gap-3'},
                        e('div', {className: 'w-28 text-xs mono truncate', style: {color: C.text}}, signal.name),
                        e('div', {className: 'flex-1 h-4 rounded overflow-hidden', style: {backgroundColor: C.border}},
                            e('div', {className: 'h-full rounded', style: {width: barWidth + '%', backgroundColor: statusColor + '80'}})
                        ),
                        e('span', {className: 'w-16 text-xs mono text-right', style: {color: C.text}}, signal.mi.toFixed(3) + ' bits'),
                        e('span', {className: 'w-8 text-center', style: {color: signal.trend === 'up' ? C.green : signal.trend === 'down' ? C.red : C.textMuted}}, trendIcon),
                        e('span', {className: 'w-12 text-xs mono text-right', style: {color: C.textMuted}},
                            signal.half_life_days ? signal.half_life_days.toFixed(0) + 'd' : '--'
                        )
                    );
                })
            );
        };

        // Correlation Heatmap (Canvas-based)
        const CorrelationHeatmap = ({ data }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!data || !data.is_valid || !data.feature_names.length) return;

                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const W = canvas.width = canvas.offsetWidth;
                const H = canvas.height = 200;

                ctx.fillStyle = C.bgCard;
                ctx.fillRect(0, 0, W, H);

                const n = data.feature_names.length;
                const cellSize = Math.min((W - 80) / n, (H - 40) / n);
                const startX = 70;
                const startY = 10;

                // Color scale: blue (-1) -> white (0) -> red (+1)
                const getColor = (corr) => {
                    if (corr >= 0) {
                        const intensity = Math.min(Math.abs(corr), 1);
                        return `rgb(${Math.round(255)}, ${Math.round(255 - intensity * 150)}, ${Math.round(255 - intensity * 200)})`;
                    } else {
                        const intensity = Math.min(Math.abs(corr), 1);
                        return `rgb(${Math.round(255 - intensity * 200)}, ${Math.round(255 - intensity * 150)}, ${Math.round(255)})`;
                    }
                };

                // Draw cells
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const corr = data.correlation_matrix[i * n + j] || 0;
                        ctx.fillStyle = getColor(corr);
                        ctx.fillRect(startX + j * cellSize, startY + i * cellSize, cellSize - 1, cellSize - 1);

                        // Draw value text for larger cells
                        if (cellSize > 25) {
                            ctx.fillStyle = Math.abs(corr) > 0.5 ? '#000' : C.textMuted;
                            ctx.font = '9px JetBrains Mono';
                            ctx.textAlign = 'center';
                            ctx.fillText(corr.toFixed(1), startX + j * cellSize + cellSize/2, startY + i * cellSize + cellSize/2 + 3);
                        }
                    }
                }

                // Draw labels
                ctx.fillStyle = C.textMuted;
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                for (let i = 0; i < n; i++) {
                    ctx.fillText(data.feature_names[i].slice(0, 8), startX - 5, startY + i * cellSize + cellSize/2 + 3);
                }

            }, [data]);

            if (!data || !data.is_valid) {
                return e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting correlation data...');
            }

            return e('canvas', { ref: canvasRef, style: { width: '100%', height: 200, display: 'block' } });
        };

        // Lag Analysis Display
        const LagAnalysisDisplay = ({ data }) => {
            if (!data || !data.signal_ready) {
                return e('div', {className: 'h-32 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting lag data...');
            }

            return e('div', {className: 'space-y-4'},
                e('div', {className: 'grid grid-cols-3 gap-4'},
                    e('div', {className: 'p-3 rounded text-center', style: {backgroundColor: C.bg}},
                        e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Optimal Lag'),
                        e('div', {className: 'text-xl font-bold mono', style: {color: data.optimal_lag_ms < 0 ? C.green : C.yellow}},
                            data.optimal_lag_ms + 'ms'
                        ),
                        e('div', {className: 'text-xs', style: {color: C.textMuted}},
                            data.optimal_lag_ms < 0 ? 'Signal leads' : 'Signal lags'
                        )
                    ),
                    e('div', {className: 'p-3 rounded text-center', style: {backgroundColor: C.bg}},
                        e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'MI at Lag'),
                        e('div', {className: 'text-xl font-bold mono'}, data.mi_at_lag.toFixed(3) + ' bits')
                    ),
                    e('div', {className: 'p-3 rounded text-center', style: {backgroundColor: C.bg}},
                        e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Status'),
                        e('div', {className: 'text-xl font-bold', style: {color: data.signal_ready ? C.green : C.yellow}},
                            data.signal_ready ? '✓ Ready' : '○ Warming'
                        )
                    )
                ),
                e('div', {className: 'text-xs', style: {color: C.textMuted}},
                    data.signal_name + ' → ' + data.target_name
                )
            );
        };

        // Interaction Signals Display
        const InteractionSignals = ({ data }) => {
            const signals = [
                { name: 'Vol × Momentum', value: data?.vol_x_momentum || 0, desc: 'High volatility + strong momentum' },
                { name: 'Regime × Inventory', value: data?.regime_x_inventory || 0, desc: 'Regime-adjusted inventory pressure' },
                { name: 'Jump × Flow', value: data?.jump_x_flow || 0, desc: 'Jump detection + flow imbalance' }
            ];

            return e('div', {className: 'space-y-4'},
                signals.map((s, i) =>
                    e('div', {key: i, className: 'flex items-center gap-4'},
                        e('div', {className: 'w-36'},
                            e('div', {className: 'text-xs font-medium', style: {color: C.text}}, s.name),
                            e('div', {className: 'text-xs', style: {color: C.textDim}}, s.desc)
                        ),
                        e('div', {className: 'flex-1 h-2 rounded overflow-hidden', style: {backgroundColor: C.border}},
                            e('div', {className: 'h-full rounded', style: {
                                width: Math.min(Math.abs(s.value) * 100, 100) + '%',
                                backgroundColor: s.value > 0.5 ? C.red : s.value > 0.2 ? C.yellow : C.green
                            }})
                        ),
                        e('span', {className: 'w-12 text-right text-xs mono'}, s.value.toFixed(2))
                    )
                )
            );
        };

        // Main Dashboard
        const Dashboard = () => {
            const [tab, setTab] = useState('overview');
            const [connected, setConnected] = useState(false);
            const [quotes, setQuotes] = useState(defaultQuotes);
            const [regime, setRegime] = useState([]);
            const [pnl, setPnl] = useState(defaultPnL);
            const [fills, setFills] = useState([]);
            const [calib, setCalib] = useState([]);
            const [calibMetrics, setCalibMetrics] = useState({ fill: defaultCalib, as: defaultCalib });
            const [signals, setSignals] = useState([]);
            const [leadLag, setLeadLag] = useState(genLeadLag());
            const [time, setTime] = useState(new Date().toLocaleTimeString());

            // New visualization state
            const [bookHistory, setBookHistory] = useState([]);
            const [priceHistory, setPriceHistory] = useState([]);
            const [quoteHistory, setQuoteHistory] = useState([]);
            const [spreadDist, setSpreadDist] = useState([]);
            const [fillStats, setFillStats] = useState([]);

            // Signal & Decision visualization state (NEW)
            const [signalHistory, setSignalHistory] = useState([]);
            const [decisionHistory, setDecisionHistory] = useState([]);
            const [kappaDiag, setKappaDiag] = useState({
                posterior_mean: 0, posterior_std: 0, confidence: 0,
                ci_95_lower: 0, ci_95_upper: 0, observation_count: 0
            });
            const [changepointDiag, setChangepointDiag] = useState({
                cp_prob_1: 0, cp_prob_5: 0, cp_prob_10: 0,
                run_length: 0, entropy: 0, detected: false
            });

            // Feature Health visualization state
            const [featureHealth, setFeatureHealth] = useState({
                signal_decay: { signals: [], alerts: [], signal_count: 0, issue_count: 0 },
                correlation: { feature_names: [], correlation_matrix: [], vif: [], condition_number: 1, is_valid: false },
                validation: { features: [], issue_count: 0, issue_rate: 0 },
                lag_analysis: { optimal_lag_ms: 0, mi_at_lag: 0, signal_ready: false },
                interactions: { vol_x_momentum: 0, regime_x_inventory: 0, jump_x_flow: 0 }
            });

            // Track accumulated fills from WebSocket
            const [wsConnected, setWsConnected] = useState(false);
            // Per-regime PnL accumulator: { Quiet: {pnl, fills}, Trending: {...}, ... }
            const [regimePnl, setRegimePnl] = useState({
                Quiet: {pnl: 0, fills: 0}, Trending: {pnl: 0, fills: 0},
                Volatile: {pnl: 0, fills: 0}, Cascade: {pnl: 0, fills: 0}
            });

            // Create chart sync manager for synchronized time scales
            const syncManagerRef = useRef(null);
            if (!syncManagerRef.current) {
                syncManagerRef.current = new ChartSyncManager();
            }
            const syncManager = syncManagerRef.current;

            // Apply full state from snapshot
            const applySnapshot = (data) => {
                if (data) {
                    setQuotes(transformQuotes(data));
                    setPnl(transformPnL(data));
                    setRegime(transformRegimeHistory(data));
                    setFills(transformFills(data));
                    setCalib(transformCalibration(data.calibration?.fill));
                    setCalibMetrics({
                        fill: {
                            brier: data.calibration?.fill?.brier_score || 0,
                            ir: data.calibration?.fill?.information_ratio || 0,
                        },
                        as: {
                            brier: data.calibration?.adverse_selection?.brier_score || 0,
                            ir: data.calibration?.adverse_selection?.information_ratio || 0,
                        }
                    });
                    setSignals(transformSignals(data));
                    // New visualization data
                    if (data.book_history) setBookHistory(data.book_history);
                    if (data.price_history) setPriceHistory(data.price_history);
                    if (data.quote_history) setQuoteHistory(data.quote_history);
                    if (data.spread_distribution) setSpreadDist(data.spread_distribution);
                    if (data.quote_fill_stats) setFillStats(data.quote_fill_stats);
                    // Signal & Decision visualization data (NEW)
                    if (data.signal_history) setSignalHistory(data.signal_history);
                    if (data.decision_history) setDecisionHistory(data.decision_history);
                    if (data.kappa_diagnostics) setKappaDiag(data.kappa_diagnostics);
                    if (data.changepoint_diagnostics) setChangepointDiag(data.changepoint_diagnostics);
                    // Feature health data
                    if (data.feature_health) setFeatureHealth(data.feature_health);
                    // Per-regime PnL from backend
                    if (data.pnl_by_regime) {
                        const rp = data.pnl_by_regime;
                        setRegimePnl({
                            Quiet: {pnl: rp.Quiet || 0, fills: 0},
                            Trending: {pnl: rp.Trending || 0, fills: 0},
                            Volatile: {pnl: rp.Volatile || 0, fills: 0},
                            Cascade: {pnl: rp.Cascade || 0, fills: 0},
                        });
                    }
                }
                setTime(new Date().toLocaleTimeString());
            };

            // Apply incremental update
            const applyUpdate = (update) => {
                if (update.quotes) {
                    setQuotes({
                        mid: update.quotes.mid.toFixed(1),
                        spreadBps: update.quotes.spread_bps.toFixed(1),
                        inventory: update.quotes.inventory.toFixed(3),
                        regime: update.quotes.regime,
                        kappa: update.quotes.kappa.toFixed(0),
                        gamma: update.quotes.gamma.toFixed(3),
                        fillProb: update.quotes.fill_prob.toFixed(1),
                        asProb: update.quotes.adverse_prob.toFixed(1),
                    });
                }
                if (update.pnl) {
                    setPnl({
                        spreadCapture: update.pnl.spread_capture,
                        adverseSelection: update.pnl.adverse_selection,
                        inventoryCost: update.pnl.inventory_cost,
                        fees: update.pnl.fees,
                    });
                }
                if (update.regime) {
                    // Append current probabilities to regime history
                    const probs = update.regime.probabilities;
                    if (probs) {
                        const now = update.timestamp_ms || Date.now();
                        setRegime(prev => [...prev.slice(-119), {
                            time: new Date(now).toLocaleTimeString(),
                            timestamp_ms: now,
                            Quiet: probs.quiet,
                            Trending: probs.trending,
                            Volatile: probs.volatile,
                            Cascade: probs.cascade,
                        }]);
                    }
                    // Update regime label in quotes display
                    if (update.regime.current) {
                        setQuotes(prev => ({...prev, regime: update.regime.current}));
                    }
                }
                setTime(new Date().toLocaleTimeString());
            };

            // Add new fill to fills array and accumulate per-regime PnL
            const addFill = (record) => {
                setFills(prev => [...prev.slice(-99), {
                    time: record.time,
                    timestamp_ms: record.timestamp_ms,
                    pnl: record.pnl,
                    cumPnl: record.cum_pnl,
                    side: record.side,
                    as: record.adverse_selection
                }]);
                // Accumulate PnL into the current regime bucket
                setQuotes(prev => {
                    const r = prev.regime || 'Quiet';
                    const fillPnl = record.pnl || 0;
                    setRegimePnl(rp => ({
                        ...rp,
                        [r]: { pnl: (rp[r]?.pnl || 0) + fillPnl, fills: (rp[r]?.fills || 0) + 1 }
                    }));
                    return prev;
                });
            };

            // Connect via WebSocket with HTTP fallback
            useEffect(() => {
                let wsClient = null;
                let httpFallbackInterval = null;

                // Create WebSocket client
                wsClient = new DashboardWebSocket(
                    WS_URL,
                    applySnapshot,  // onSnapshot
                    applyUpdate,    // onUpdate
                    addFill,        // onFill
                    () => {         // onConnected
                        setConnected(true);
                        setWsConnected(true);
                        // Clear HTTP fallback if running
                        if (httpFallbackInterval) {
                            clearInterval(httpFallbackInterval);
                            httpFallbackInterval = null;
                        }
                    },
                    () => {         // onDisconnected
                        setConnected(false);
                        setWsConnected(false);
                        // Start HTTP fallback polling
                        if (!httpFallbackInterval) {
                            httpFallbackInterval = setInterval(async () => {
                                const { data, connected: isConnected } = await fetchDashboard();
                                if (isConnected && data) {
                                    setConnected(true);
                                    applySnapshot(data);
                                }
                            }, 1000);
                        }
                    }
                );

                // Start WebSocket connection
                wsClient.connect();

                return () => {
                    if (wsClient) wsClient.close();
                    if (httpFallbackInterval) clearInterval(httpFallbackInterval);
                };
            }, []);

            const tabs = [
                {id: 'overview', label: 'Overview'},
                {id: 'book', label: 'Order Book'},
                {id: 'calibration', label: 'Calibration'},
                {id: 'regime', label: 'Regime'},
                {id: 'signals', label: 'Signals'},
                {id: 'features', label: 'Features'},
                {id: 'pnl', label: 'PnL'}
            ];

            return e('div', {className: 'min-h-screen p-4 md:p-6', style: {backgroundColor: C.bg, color: C.text}},
                // Header
                e('header', {className: 'mb-6'},
                    e('div', {className: 'flex flex-col md:flex-row md:items-center md:justify-between gap-4'},
                        e('div', null,
                            e('h1', {className: 'text-2xl md:text-3xl font-bold tracking-tight'}, 'STOCHASTIC MM'),
                            e('p', {className: 'text-sm mt-1', style: {color: C.textMuted}}, 'Real-time Market Making Analytics • Hyperliquid BTC-PERP')
                        ),
                        e('div', {className: 'flex items-center gap-4'},
                            e('div', {className: 'flex items-center gap-2'},
                                e('div', {className: 'w-2 h-2 rounded-full pulse-glow', style: {backgroundColor: connected ? C.green : C.red}}),
                                e('span', {className: 'text-xs uppercase tracking-wider mono', style: {color: C.textMuted}},
                                    connected ? (wsConnected ? 'WS Live' : 'HTTP') : 'Disconnected')
                            ),
                            e('span', {className: 'text-xs tabular-nums mono', style: {color: C.textMuted}}, time)
                        )
                    ),
                    e('nav', {className: 'flex gap-1 mt-6 overflow-x-auto pb-2'},
                        tabs.map(t => e(Tab, {key: t.id, id: t.id, label: t.label, active: tab === t.id, onClick: setTab}))
                    )
                ),

                // Live Banner
                e(Card, {accent: C.accent},
                    e('div', {className: 'grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4'},
                        e(Metric, {label: 'Mid Price', value: quotes.mid, unit: 'USD'}),
                        e(Metric, {label: 'Spread', value: quotes.spreadBps, unit: 'bps'}),
                        e(Metric, {label: 'Inventory', value: quotes.inventory, unit: 'BTC'}),
                        e('div', {className: 'flex flex-col'},
                            e('span', {className: 'text-xs uppercase tracking-wider mb-1 mono', style: {color: C.textMuted}}, 'Regime'),
                            e(RegimeBadge, {regime: quotes.regime})
                        ),
                        e(Metric, {label: 'Kappa', value: quotes.kappa}),
                        e(Metric, {label: 'Gamma', value: quotes.gamma}),
                        e(Metric, {label: 'P(Fill)', value: quotes.fillProb, unit: '%'}),
                        e(Metric, {label: 'P(Adverse)', value: quotes.asProb, unit: '%'})
                    )
                ),

                // Content
                e('div', {className: 'mt-6'},
                    tab === 'overview' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Cumulative PnL', subtitle: 'Last hour', accent: C.green}, e(PnLChart, {data: fills, syncManager})),
                        e(Card, {title: 'PnL Attribution', subtitle: 'Component breakdown', accent: C.purple}, e(WaterfallChart, {data: pnl})),
                        e(Card, {title: 'Regime Probabilities', subtitle: 'HMM belief state', accent: C.regimeTrending}, e(RegimeChart, {data: regime, syncManager})),
                        e(Card, {title: 'Fill Calibration', subtitle: 'Predicted vs realized', accent: C.accent}, e(CalibrationChart, {data: calib}))
                    ),

                    tab === 'book' && e('div', {className: 'space-y-6'},
                        // Top row: Price Chart AND Order Book Heat Map SIDE-BY-SIDE (same size)
                        e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                            e(Card, {title: 'Mid Price History', subtitle: '30-minute rolling window', accent: C.accent},
                                e(PriceChart, {priceData: priceHistory, quoteData: quoteHistory, syncManager})
                            ),
                            e(Card, {title: 'Order Book Heat Map', subtitle: 'Time × Price with size intensity', accent: C.purple},
                                e(BookHeatMap, {data: bookHistory, quoteData: quoteHistory, syncManager})
                            )
                        ),
                        // Second row: Depth Chart (full width)
                        e(Card, {title: 'Current Book Depth', subtitle: 'Bid/Ask liquidity profile', accent: C.accent},
                            bookHistory.length > 0
                                ? e(DepthChart, {data: bookHistory[bookHistory.length - 1]})
                                : e('div', {className: 'h-64 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for book data...')
                        ),
                        // Third row: Quote Distribution
                        e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                            e(Card, {title: 'Spread Distribution', subtitle: 'Histogram of realized spreads', accent: C.orange},
                                spreadDist.length > 0
                                    ? e(SpreadHistogram, {data: spreadDist})
                                    : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting spread data...')
                            ),
                            e(Card, {title: 'Fill Rate by Level', subtitle: 'Which quote levels get filled', accent: C.green},
                                fillStats.length > 0
                                    ? e(FillRateChart, {data: fillStats})
                                    : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Collecting fill data...')
                            )
                        ),
                        // Stats summary
                        e('div', {className: 'grid grid-cols-2 md:grid-cols-4 gap-4'},
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.accent}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Price Points'),
                                e('div', {className: 'text-2xl font-bold mono'}, priceHistory.length)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.purple}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Book Snapshots'),
                                e('div', {className: 'text-2xl font-bold mono'}, bookHistory.length)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.orange}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Spread Samples'),
                                e('div', {className: 'text-2xl font-bold mono'}, spreadDist.reduce((a, b) => a + b.count, 0))
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: `3px solid ${C.green}`}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Total Fills'),
                                e('div', {className: 'text-2xl font-bold mono'}, fillStats.reduce((a, b) => a + b.fill_count, 0))
                            )
                        )
                    ),

                    tab === 'calibration' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Fill Probability Calibration', accent: C.accent},
                            calib.length > 0 ? e(CalibrationChart, {data: calib}) : e('div', {className: 'h-48 flex items-center justify-center', style: {color: C.textMuted}}, 'Waiting for data...'),
                            e('div', {className: 'mt-4 grid grid-cols-2 gap-4'},
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Brier Score'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.fill.brier.toFixed(3)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.fill.brier < 0.25 ? C.green : calibMetrics.fill.brier < 0.35 ? C.yellow : C.red}}, calibMetrics.fill.brier < 0.25 ? 'Good' : calibMetrics.fill.brier < 0.35 ? 'Fair' : 'Poor')
                                ),
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Info Ratio'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.fill.ir.toFixed(2)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.fill.ir > 1.0 ? C.green : calibMetrics.fill.ir > 0.8 ? C.yellow : C.red}}, calibMetrics.fill.ir > 1.0 ? 'Predictive' : calibMetrics.fill.ir > 0.8 ? 'Marginal' : 'No edge')
                                )
                            )
                        ),
                        e(Card, {title: 'Adverse Selection Calibration', accent: C.red},
                            e(CalibrationChart, {data: transformCalibration(null)}),
                            e('div', {className: 'mt-4 grid grid-cols-2 gap-4'},
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Brier Score'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.as.brier.toFixed(3)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.as.brier < 0.25 ? C.green : calibMetrics.as.brier < 0.35 ? C.yellow : C.red}}, calibMetrics.as.brier < 0.25 ? 'Good' : calibMetrics.as.brier < 0.35 ? 'Fair' : 'Poor')
                                ),
                                e('div', {className: 'p-3 rounded', style: {backgroundColor: C.bg}},
                                    e('div', {className: 'text-xs uppercase mb-2 mono', style: {color: C.textMuted}}, 'Info Ratio'),
                                    e('div', {className: 'text-xl font-bold mono'}, calibMetrics.as.ir.toFixed(2)),
                                    e('div', {className: 'text-xs mt-1', style: {color: calibMetrics.as.ir > 1.0 ? C.green : calibMetrics.as.ir > 0.8 ? C.yellow : C.red}}, calibMetrics.as.ir > 1.0 ? 'Predictive' : calibMetrics.as.ir > 0.8 ? 'Marginal' : 'No edge')
                                )
                            )
                        )
                    ),

                    tab === 'regime' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'Regime History', subtitle: 'HMM belief evolution', accent: C.regimeTrending, className: 'lg:col-span-2'},
                            e(RegimeChart, {data: regime, syncManager}),
                            e('div', {className: 'flex gap-4 mt-4 flex-wrap'},
                                ['Quiet', 'Trending', 'Volatile', 'Cascade'].map(r =>
                                    e('div', {key: r, className: 'flex items-center gap-2'},
                                        e('div', {className: 'w-3 h-3 rounded', style: {backgroundColor: C['regime' + r]}}),
                                        e('span', {className: 'text-xs', style: {color: C.textMuted}}, r)
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Regime Parameters', accent: C.accent},
                            e('div', {className: 'space-y-4'},
                                [{r: 'Quiet', g: 0.3, k: 1.0, f: 5}, {r: 'Trending', g: 0.5, k: 0.7, f: 10}, {r: 'Volatile', g: 0.8, k: 1.5, f: 15}, {r: 'Cascade', g: 2.0, k: 5.0, f: 50}].map(p =>
                                    e('div', {key: p.r, className: 'p-3 rounded border flex items-center justify-between', style: {backgroundColor: C.bg, borderColor: C.border, borderLeftWidth: 3, borderLeftColor: C['regime' + p.r]}},
                                        e(RegimeBadge, {regime: p.r}),
                                        e('div', {className: 'flex gap-4 text-xs mono', style: {color: C.textMuted}},
                                            e('span', null, 'γ=' + p.g),
                                            e('span', null, 'κ×' + p.k),
                                            e('span', null, p.f + 'bps')
                                        )
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Current Blended', accent: C.green},
                            e('div', {className: 'grid grid-cols-2 gap-4'},
                                e(Metric, {label: 'Eff. Gamma', value: quotes.gamma}),
                                e(Metric, {label: 'Kappa Mult', value: '1.15'}),
                                e(Metric, {label: 'Floor', value: '8.0', unit: 'bps'}),
                                e(Metric, {label: 'Max Inv', value: '0.65', unit: 'BTC'})
                            )
                        )
                    ),

                    tab === 'signals' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        // Kappa Time Series (full width)
                        e(Card, {title: 'Kappa (Fill Intensity)', subtitle: 'With 95% confidence interval', accent: C.accent, className: 'lg:col-span-2'},
                            e(KappaChart, {data: signalHistory})
                        ),
                        
                        // Quote Decision Log (full width)
                        e(Card, {title: 'Quote Decision Log', subtitle: 'Why spreads were set', accent: C.blue, className: 'lg:col-span-2'},
                            e(DecisionLogTable, {data: decisionHistory})
                        ),
                        
                        // Kappa Diagnostics
                        e(Card, {title: 'Kappa Diagnostics', subtitle: 'Bayesian posterior', accent: C.accent},
                            e(KappaDiagPanel, {diag: kappaDiag})
                        ),
                        
                        // Changepoint Diagnostics
                        e(Card, {title: 'Changepoint Detection', subtitle: 'Regime transition', accent: C.orange},
                            e(ChangepointDiagPanel, {diag: changepointDiag})
                        ),
                        
                        // Momentum Signal
                        e(Card, {title: 'Momentum (bps)', subtitle: 'Signed price momentum', accent: C.purple},
                            e(SignalTimeSeriesChart, {data: signalHistory, field: 'momentum_bps', label: 'Momentum', color: C.purple})
                        ),
                        
                        // Flow Imbalance
                        e(Card, {title: 'Flow Imbalance', subtitle: 'Order flow direction', accent: C.blue},
                            e(SignalTimeSeriesChart, {data: signalHistory, field: 'flow_imbalance', label: 'Imbalance', color: C.blue})
                        ),
                        
                        // Volatility
                        e(Card, {title: 'Volatility (σ)', subtitle: 'Clean bipower variation', accent: C.green},
                            e(SignalTimeSeriesChart, {data: signalHistory, field: 'sigma', label: 'σ', color: C.green})
                        ),
                        
                        // Jump Ratio
                        e(Card, {title: 'Jump Ratio', subtitle: 'RV/BV toxicity indicator', accent: C.red},
                            e(SignalTimeSeriesChart, {data: signalHistory, field: 'jump_ratio', label: 'Jump', color: C.red})
                        )
                    ),

                    tab === 'features' && e('div', {className: 'space-y-6'},
                        // Signal Health Panel (full width)
                        e(Card, {title: 'Signal Health', subtitle: 'MI trends and half-lives', accent: C.accent, className: 'lg:col-span-2'},
                            e('div', {className: 'mb-2 flex gap-4 text-xs', style: {color: C.textMuted}},
                                e('span', null, 'Signal'),
                                e('span', {className: 'flex-1'}, 'Mutual Information'),
                                e('span', {className: 'w-16 text-right'}, 'MI'),
                                e('span', {className: 'w-8 text-center'}, 'Trend'),
                                e('span', {className: 'w-12 text-right'}, 'Half-life')
                            ),
                            e(SignalHealthChart, {signals: featureHealth.signal_decay?.signals || []})
                        ),

                        // Alerts (if any)
                        featureHealth.signal_decay?.alerts?.length > 0 &&
                            e(Card, {title: 'Active Alerts', accent: C.red},
                                e('div', {className: 'space-y-2'},
                                    featureHealth.signal_decay.alerts.map((alert, i) =>
                                        e('div', {key: i, className: 'p-3 rounded flex items-center gap-3', style: {backgroundColor: alert.severity === 'critical' ? C.red + '20' : C.yellow + '20'}},
                                            e('span', {style: {color: alert.severity === 'critical' ? C.red : C.yellow}}, alert.severity === 'critical' ? '🔴' : '⚠'),
                                            e('span', {className: 'font-medium', style: {color: C.text}}, alert.signal_name),
                                            e('span', {className: 'flex-1 text-sm', style: {color: C.textMuted}}, alert.message)
                                        )
                                    )
                                )
                            ),

                        // Two-column layout for correlation and lag analysis
                        e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                            // Correlation Heatmap
                            e(Card, {title: 'Feature Correlations', subtitle: 'Condition #: ' + (featureHealth.correlation?.condition_number?.toFixed(1) || '-'), accent: C.purple},
                                e(CorrelationHeatmap, {data: featureHealth.correlation})
                            ),

                            // Lag Analysis
                            e(Card, {title: 'Cross-Exchange Lag', subtitle: 'Lead-lag detection', accent: C.blue},
                                e(LagAnalysisDisplay, {data: featureHealth.lag_analysis})
                            )
                        ),

                        // Interaction Signals
                        e(Card, {title: 'Interaction Signals', subtitle: 'Non-linear feature combinations', accent: C.orange},
                            e(InteractionSignals, {data: featureHealth.interactions})
                        ),

                        // Summary stats
                        e('div', {className: 'grid grid-cols-2 md:grid-cols-4 gap-4'},
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: '3px solid ' + C.accent}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Tracked Signals'),
                                e('div', {className: 'text-2xl font-bold mono'}, featureHealth.signal_decay?.signal_count || 0)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: '3px solid ' + (featureHealth.signal_decay?.issue_count > 0 ? C.yellow : C.green)}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Issues'),
                                e('div', {className: 'text-2xl font-bold mono', style: {color: featureHealth.signal_decay?.issue_count > 0 ? C.yellow : C.green}}, featureHealth.signal_decay?.issue_count || 0)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: '3px solid ' + C.purple}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Features Tracked'),
                                e('div', {className: 'text-2xl font-bold mono'}, featureHealth.correlation?.feature_names?.length || 0)
                            ),
                            e('div', {className: 'p-4 rounded', style: {backgroundColor: C.bgCard, borderLeft: '3px solid ' + (featureHealth.lag_analysis?.signal_ready ? C.green : C.yellow)}},
                                e('div', {className: 'text-xs uppercase mb-1 mono', style: {color: C.textMuted}}, 'Lag Signal'),
                                e('div', {className: 'text-2xl font-bold', style: {color: featureHealth.lag_analysis?.signal_ready ? C.green : C.yellow}},
                                    featureHealth.lag_analysis?.signal_ready ? '✓ Ready' : 'Warming'
                                )
                            )
                        )
                    ),

                    tab === 'pnl' && e('div', {className: 'grid grid-cols-1 lg:grid-cols-2 gap-6'},
                        e(Card, {title: 'PnL Attribution', accent: C.green},
                            e(WaterfallChart, {data: pnl}),
                            e('div', {className: 'mt-4 p-3 rounded mono text-xs', style: {backgroundColor: C.bg}},
                                e('span', {style: {color: C.textMuted}}, 'Gross: '),
                                e('span', {style: {color: (pnl.spreadCapture + pnl.adverseSelection + pnl.inventoryCost + pnl.fees) >= 0 ? C.green : C.red}},
                                    '$' + (pnl.spreadCapture + pnl.adverseSelection + pnl.inventoryCost + pnl.fees).toFixed(2)
                                )
                            )
                        ),
                        e(Card, {title: 'Cumulative', accent: C.accent}, e(PnLChart, {data: fills, syncManager})),
                        e(Card, {title: 'By Regime', accent: C.purple},
                            e('div', {className: 'space-y-4'},
                                (() => {
                                    const totalFills = Object.values(regimePnl).reduce((s, v) => s + v.fills, 0) || 1;
                                    return ['Quiet', 'Trending', 'Volatile', 'Cascade'].map(r => ({
                                        r, pnl: regimePnl[r]?.pnl || 0, pct: ((regimePnl[r]?.fills || 0) / totalFills * 100)
                                    }));
                                })().map(x =>
                                    e('div', {key: x.r, className: 'flex items-center gap-4'},
                                        e('div', {className: 'w-20'}, e(RegimeBadge, {regime: x.r})),
                                        e('div', {className: 'flex-1'},
                                            e('div', {className: 'h-1.5 rounded-full overflow-hidden', style: {backgroundColor: C.border}},
                                                e('div', {className: 'h-full rounded-full', style: {width: (x.pct) + '%', backgroundColor: C['regime' + x.r]}})
                                            )
                                        ),
                                        e('span', {className: 'w-16 text-right text-xs tabular-nums mono', style: {color: x.pnl >= 0 ? C.green : C.red}}, '$' + x.pnl.toFixed(0)),
                                        e('span', {className: 'w-10 text-right text-xs', style: {color: C.textMuted}}, x.pct + '%')
                                    )
                                )
                            )
                        ),
                        e(Card, {title: 'Recent Fills', accent: C.orange},
                            e('div', {className: 'space-y-2 max-h-64 overflow-y-auto'},
                                fills.slice(-10).reverse().map((f, i) =>
                                    e('div', {key: i, className: 'flex items-center justify-between p-2 rounded text-xs mono', style: {backgroundColor: i % 2 === 0 ? C.bg : 'transparent'}},
                                        e('span', {style: {color: C.textMuted}}, f.time),
                                        e('span', {style: {color: f.side === 'BID' ? C.green : C.red}}, f.side),
                                        e('span', {style: {color: f.pnl >= 0 ? C.green : C.red}}, (f.pnl >= 0 ? '+' : '') + '$' + f.pnl.toFixed(2)),
                                        e('span', {style: {color: C.textMuted}}, 'AS:' + f.as)
                                    )
                                )
                            )
                        )
                    )
                ),

                // Footer
                e('footer', {className: 'mt-8 pt-6 border-t text-center', style: {borderColor: C.border}},
                    e('p', {className: 'text-xs', style: {color: C.textMuted}}, 'Stochastic Market Making Dashboard • Building in Public'),
                    e('p', {className: 'text-xs mt-1', style: {color: C.textDim}}, 'From GLFT theory to profitable execution')
                )
            );
        };

        ReactDOM.render(e(Dashboard), document.getElementById('root'));
    </script>
</body>
</html>
