# Session Checkpoint - 2025-12-30 (Final)

## Session Summary

This session completed three major tasks:
1. Fixed margin/leverage bugs preventing Kelly-Stochastic from placing orders
2. Implemented first-principles API-based leverage configuration
3. Validated on testnet (10 minute run)

### Major Bug Fixes (Earlier This Session)

### Bug 1: Kelly Time Horizon (Previous Session)
**Root Cause:**
- Kelly-Stochastic reused GLFT inventory time horizon T = 1/λ (~4ms)
- First-passage fill probability P(fill) = 2Φ(-δ/(σ√τ)) with τ = 4ms gives P ≈ 0

**Fix:**
- Added `KellyTimeHorizonMethod` enum with `DiffusionBased` default: τ = (δ_char/σ)²

### Bug 2: Margin Double-Counting (This Session)
**Root Cause:**
- `ladder_strat.rs` subtracted position margin from `margin_available`
- But `margin_available` from exchange **already** accounts for position margin
- Result: `available_margin = 640.27 - 657.04 = 0.00` → zero allocations

**Fix:**
- Removed the position margin subtraction in `ladder_strat.rs`
- `available_margin = market_params.margin_available` (use exchange value directly)

### Bug 3: Wrong Leverage Value (This Session)
**Root Cause:**
- Used `current_leverage` (~1.01) instead of `max_leverage` (3.0)
- `current_leverage` = how leveraged the account IS
- `max_leverage` = how much leverage is ALLOWED
- With leverage=1, `margin_per_unit = 88000/1 = 88000`, making `max_by_margin` tiny

**Fix:**
- Changed `params.rs` to use `margin_sizer.summary().max_leverage`
- With leverage=3, `margin_per_unit = 88000/3 = 29333`, proper allocation

**Result After Fixes:**
```
leverage=3.00, available_margin=641.02, margin_per_unit=29439.70
max_by_margin=0.021774 (can allocate ~0.022 BTC)
raw_size_0=0.005924, notional_0=523.17
bid_levels=4 ask_levels=4 best_bid=(88280.0, 0.00592)
```

Previous sessions completed:
1. Strategy integration with config flags
2. Alpha calibration from real fill data
3. Prometheus metrics for monitoring
4. Dynamic Kelly fraction based on volatility regime

## Completed Tasks

### 5. Fix Margin Double-Counting and Leverage Value (DONE - This Session)

**Files Modified:**
- `strategy/ladder_strat.rs`: Removed double-counting of position margin
- `strategy/params.rs`: Changed to use `max_leverage` instead of `current_leverage`

**Before (buggy) - ladder_strat.rs:**
```rust
let leverage = market_params.leverage.max(1.0);
let position_margin_cost = position.abs() * (market_params.microprice / leverage);
let available_margin = (market_params.margin_available - position_margin_cost).max(0.0);
```

**After (fixed) - ladder_strat.rs:**
```rust
// Available margin from exchange already accounts for position margin
let leverage = market_params.leverage.max(1.0);
let available_margin = market_params.margin_available;
let available_position = (max_position - position.abs()).max(0.0);
```

**Before (buggy) - params.rs:**
```rust
leverage: sources.margin_sizer.state().current_leverage,
```

**After (fixed) - params.rs:**
```rust
// Use max_leverage (allowed leverage) not current_leverage (how levered we are)
leverage: sources.margin_sizer.summary().max_leverage,
```

**Key Insight:**
- `margin_available` from Hyperliquid API = `account_value - margin_used`
- `margin_used` already includes position margin
- No need to subtract position margin again!

### 0. Fix Kelly Time Horizon for First-Passage Probability (DONE)

**Files Modified:**
- `config.rs`: Added `KellyTimeHorizonMethod` enum and tau config params
- `market_params.rs`: Added `kelly_time_horizon` field
- `params.rs`: Added `calculate_kelly_time_horizon()` helper, updated aggregator
- `ladder_strat.rs`: Use `market_params.kelly_time_horizon` in KellyStochasticParams

**New Config Params in StochasticConfig:**
```rust
pub kelly_time_horizon_method: KellyTimeHorizonMethod, // Default: DiffusionBased
pub kelly_tau_fixed: f64,                              // 60.0s (for Fixed method)
pub kelly_tau_min: f64,                                // 10.0s (floor)
pub kelly_tau_max: f64,                                // 600.0s (ceiling)
pub kelly_char_depth_bps: f64,                         // 25.0 bps
```

**Key Formula (DiffusionBased):**
```
τ = (δ_char / σ)².clamp(τ_min, τ_max)
```

This gives meaningful fill probabilities that produce non-zero Kelly allocations.

### 1. Integrate Kelly-Stochastic into LadderStrategy (DONE)

**Files Modified:**
- `config.rs`: Added `use_kelly_stochastic` flag and Kelly params to `StochasticConfig`
- `market_params.rs`: Added Kelly fields to `MarketParams`
- `params.rs`: Added `KellyStochasticConfigParams` and updated `ParameterAggregator`
- `ladder_strat.rs`: Updated optimizer calls to use Kelly-Stochastic when enabled

**Config Flags:**
```rust
pub struct StochasticConfig {
    pub use_kelly_stochastic: bool,        // Enable/disable Kelly allocation
    pub kelly_alpha_touch: f64,            // Informed probability at touch (0.15)
    pub kelly_alpha_decay_bps: f64,        // Alpha decay depth (10bp)
    pub kelly_fraction: f64,               // Base Kelly fraction (0.25)
}
```

### 2. Calibrate alpha_touch from Real Fill Data (DONE)

**Files Modified:**
- `adverse_selection/depth_decay.rs`: Added alpha tracking and calibration

**New Fields in DepthDecayAS:**
```rust
pub alpha_touch: f64,           // Calibrated alpha [0.01, 0.5]
bucket_alpha_ewma: [f64; 4],    // EWMA alpha per bucket
bucket_informed_count: [usize; 4], // Fills with AS > threshold
bucket_total_count: [usize; 4], // Total fills per bucket
informed_threshold_bps: f64,    // 1bp threshold for "informed"
```

**New Methods:**
- `calibrated_alpha_touch()` - Get calibrated alpha
- `alpha_at_depth(depth_bps)` - Get alpha at arbitrary depth: α(δ) = α_touch × exp(-δ/δ_char)

**Calibration Logic:**
- Tracks fills with |AS| > threshold as "informed"
- Updates `alpha_touch` during calibration cycles (every 20 fills)
- Smoothed EWMA update with 0.2 smoothing factor
- Clamped to [0.01, 0.5] range

### 3. Add Prometheus Metrics for Kelly Monitoring (DONE)

**Files Modified:**
- `infra/metrics.rs`: Added Kelly-Stochastic metrics

**New Metrics:**
- `mm_kelly_stochastic_enabled` - Whether Kelly allocation is active (0/1)
- `mm_kelly_alpha_touch` - Calibrated informed probability at touch
- `mm_kelly_fraction` - Current Kelly fraction being used
- `mm_kelly_alpha_decay_bps` - Alpha decay characteristic depth

**New Method:**
```rust
pub fn update_kelly_stochastic(
    &self,
    enabled: bool,
    alpha_touch: f64,
    kelly_fraction: f64,
    alpha_decay_bps: f64,
)
```

### 4. Dynamic Kelly Fraction Based on Volatility Regime (DONE)

**Files Modified:**
- `estimator/volatility.rs`: Added `kelly_fraction_multiplier()` to `VolatilityRegime`
- `strategy/ladder_strat.rs`: Apply regime-based multiplier to Kelly fraction

**Regime Multipliers:**
| Regime | Multiplier | Effective Kelly (base 0.25) |
|--------|------------|---------------------------|
| Low | 1.5x | 0.375 (more aggressive) |
| Normal | 1.0x | 0.25 (standard) |
| High | 0.5x | 0.125 (conservative) |
| Extreme | 0.25x | 0.0625 (very conservative) |

**Implementation:**
```rust
let regime_multiplier = market_params.volatility_regime.kelly_fraction_multiplier();
let dynamic_kelly = (market_params.kelly_fraction * regime_multiplier).clamp(0.05, 0.75);
```

### 6. First-Principles API-Based Leverage (DONE - This Session)

**Problem:**
- Leverage was hardcoded with arbitrary defaults (3.0x, 20.0x)
- Different assets have different max leverage (BTC: 50x, memecoins: 3x)
- Some assets have tiered leverage (reduced max at higher notional)

**Solution - New Types in `meta.rs`:**
```rust
/// Single source of truth for leverage from API
pub struct AssetLeverageConfig {
    pub asset: String,
    pub max_leverage: f64,
    pub isolated_only: bool,
    pub tiers: Vec<LeverageTier>,  // Tiered leverage support
}

pub struct LeverageTier {
    pub lower_bound: f64,   // Notional threshold (USD)
    pub max_leverage: f64,  // Max at this tier
}
```

**New Methods in `MarginConfig`:**
```rust
// Preferred: derive from API metadata
MarginConfig::from_asset_meta(asset_meta: &AssetMeta)

// With tiered leverage
MarginConfig::from_leverage_config(leverage_config: AssetLeverageConfig)

// Get effective leverage at position size
config.leverage_at_notional(notional: f64) -> f64
```

**Integration in `market_maker.rs`:**
```rust
// Changed from:
let margin_config = MarginConfig::default();  // Arbitrary 3x

// To:
let margin_config = MarginConfig::from_asset_meta(asset_meta);  // API-derived
```

**Files Modified:**
- `src/meta.rs`: Added `AssetLeverageConfig`, `LeverageTier`, methods
- `src/market_maker/infra/margin.rs`: Added `from_asset_meta()`, `leverage_at_notional()`, tiered support
- `src/bin/market_maker.rs`: Use `MarginConfig::from_asset_meta()`

**Tests Added:** 5 new tests for tiered leverage

### 7. Testnet Validation Run (DONE - 10 minutes)

**Results:**
- ✅ Market maker started successfully
- ✅ Kelly-Stochastic optimizer producing non-zero allocations
- ✅ 4-level bid/ask ladders calculated
- ✅ BID orders placed and managed
- ⚠️ SELL orders rejected due to existing short position (-0.11 BTC) hitting exchange position limit

**Key Observations:**
- `binding=Position` - position constraint is the limiting factor
- `kelly_fraction=0.250`, `regime=Normal`
- Leverage from API working correctly (50x for BTC)

## Build Status
- **cargo build**: ✅ Pass
- **cargo clippy**: ✅ 1 pre-existing warning (unrelated)
- **cargo test**: ✅ 334 passed, 0 failed

## Files Modified Summary

| File | Changes |
|------|---------|
| `config.rs` | Added `use_kelly_stochastic`, Kelly params, `KellyTimeHorizonMethod` |
| `market_params.rs` | Added Kelly fields, `kelly_time_horizon`, `kelly_stochastic()` extractor |
| `strategy/params.rs` | Added `KellyStochasticConfigParams`, fixed leverage to use `max_leverage` |
| `strategy/ladder_strat.rs` | Kelly-Stochastic integration, fixed margin double-counting |
| `adverse_selection/depth_decay.rs` | Added alpha tracking, calibration, new methods |
| `estimator/volatility.rs` | Added `kelly_fraction_multiplier()` |
| `infra/metrics.rs` | Added Kelly metrics to Prometheus output |
| `meta.rs` | Added `AssetLeverageConfig`, `LeverageTier` for API-based leverage |
| `infra/margin.rs` | Added `from_asset_meta()`, `leverage_at_notional()`, tiered support |
| `bin/market_maker.rs` | Changed to use `MarginConfig::from_asset_meta()` |

## Usage

### Enable Kelly-Stochastic in Production

Config-driven (default ON):
```rust
StochasticConfig::default()  // use_kelly_stochastic = true
```

Or explicitly:
```rust
StochasticConfig::passive_only().with_kelly_stochastic()
```

### Monitor via Prometheus
```
mm_kelly_stochastic_enabled{asset="BTC"} 1
mm_kelly_alpha_touch{asset="BTC"} 0.1523
mm_kelly_fraction{asset="BTC"} 0.2500
mm_kelly_alpha_decay_bps{asset="BTC"} 10.00
```

### Debug Logs
Look for log lines:
```
Constrained optimizer applied to bids
    binding=Margin
    margin_used=1234.56
    kelly_stochastic=true
    kelly_fraction=0.250
    regime=Normal
```

## Key Formulas

### First-Passage Fill Probability
```
P(fill at δ in time τ) = 2Φ(-δ/(σ√τ))
```

### Kelly Criterion
```
f*(δ) = E[R|fill] / Var[R|fill]

Where:
- E[R|fill] = (1-α) × SC - α × AS
- Var[R|fill] = (SC + AS)² × α × (1-α)
```

### Depth-Dependent Alpha
```
α(δ) = α_touch × exp(-δ/δ_char)
```

### Dynamic Kelly Fraction
```
effective_kelly = base_kelly × regime_multiplier
                = 0.25 × kelly_fraction_multiplier(regime)
                ∈ [0.05, 0.75]
```

## Architecture Overview

```
MarketMaker
    ├── StochasticConfig
    │   ├── use_kelly_stochastic: bool
    │   ├── kelly_alpha_touch: f64
    │   ├── kelly_alpha_decay_bps: f64
    │   └── kelly_fraction: f64
    │
    ├── MarketParams (runtime)
    │   ├── volatility_regime: VolatilityRegime
    │   ├── use_kelly_stochastic: bool
    │   └── kelly_* fields
    │
    ├── LadderStrategy.generate_ladder()
    │   └── ConstrainedLadderOptimizer
    │       ├── optimize() - Proportional MV allocation
    │       └── optimize_kelly_stochastic() - First-passage + Kelly
    │
    ├── DepthDecayAS (calibration)
    │   ├── record_pending_fill() → resolve_pending_fills()
    │   └── calibrate() → update alpha_touch from fills
    │
    └── PrometheusMetrics
        └── update_kelly_stochastic() → mm_kelly_* metrics
```

## Next Steps / Known Issues

### 1. Exchange Position Limit Handling
During testnet run, SELL orders were rejected with:
```
Order would exceed maximum position size for current leverage
```

**Root Cause:** Exchange enforces position limits based on account value and leverage settings. With existing short position (-0.11 BTC), adding more short exposure exceeds limit.

**Potential Fixes:**
- Add pre-flight check against exchange position limits
- Query `maxPositionSize` from user state API
- Implement position-aware order sizing

### 2. Tiered Margin Table Parsing
The API provides `marginTables` with tiered leverage by notional size. Current implementation supports tiered structure but doesn't yet parse the margin table response.

**API Response Format:**
```json
"marginTables": [
    [50, { "marginTiers": [{ "lowerBound": "0.0", "maxLeverage": 50 }] }],
    [51, { "marginTiers": [
        { "lowerBound": "0.0", "maxLeverage": 10 },
        { "lowerBound": "3000000.0", "maxLeverage": 5 }
    ]}]
]
```

### 3. Production Readiness Checklist
- [ ] Add exchange position limit pre-flight check
- [ ] Parse margin tables for large position trading
- [ ] Extended testnet run with position management
- [ ] Mainnet deployment with small size limits
