# Session Checkpoint - Position Limit Harmonization Complete

**Date**: 2025-12-30
**Session Focus**: Harmonizing position limits across the project - eliminating static limit usage in favor of first-principles derived limits
**Test Count**: 404 tests passing

---

## Completed Work (This Session)

### Position Limit Harmonization

**Problem Identified**: Two parallel position limit systems existed but were not synchronized:
- **Static limit** (`config.max_position = 0.05`) - Used by ReduceOnlyConfig, MessageContext, FillState
- **Dynamic limit** (`market_params.dynamic_max_position = 0.283`) - Used by strategies

This caused the bug where:
1. Strategy sizes orders based on dynamic limit (0.283 BTC)
2. Position grows to 0.088 BTC (within dynamic limit, 31% utilization)
3. Reduce-only filter triggers on static limit (0.05 BTC, 177% utilization)
4. One-sided quoting, system stuck in reduce-only mode

**Solution**: Added `effective_max_position` field to MarketMaker as THE single source of truth.

### Implementation Summary

#### New Field in MarketMaker (`src/market_maker/mod.rs:104-118`)
```rust
/// Effective max position SIZE (contracts), updated each quote cycle.
///
/// Derived from first principles:
/// - During warmup: Uses config.max_position as fallback
/// - After warmup: Uses dynamic_max_position_value / mid_price
///
/// Formula: max_position = min(leverage_limit, volatility_limit) / mid_price
/// where:
///   leverage_limit = account_value × max_leverage
///   volatility_limit = (equity × risk_fraction) / (num_sigmas × σ × √T)
///
/// This is THE source of truth for all position limit checks.
effective_max_position: f64,
```

#### Update Logic (each quote cycle)
```rust
// CRITICAL: Update cached effective max_position from first principles
let new_effective = market_params.effective_max_position(self.config.max_position);
self.effective_max_position = new_effective;
```

### All Consumer Updates

| Location | Previous | Now |
|----------|----------|-----|
| ReduceOnlyConfig (ladder mode) | `config.max_position` | `effective_max_position` |
| ReduceOnlyConfig (single mode) | `config.max_position` | `effective_max_position` |
| MessageContext (4 places) | `config.max_position` | `effective_max_position` |
| FillState.max_position | `config.max_position` | `effective_max_position` |
| safety_sync() reduce-only check | `config.max_position` | `effective_max_position` |
| Prometheus metrics | `config.max_position` | `effective_max_position` |
| Capacity warnings | `config.max_position` | `effective_max_position` |
| RiskState construction | `config.max_position` | `effective_max_position` |

### Intentionally Unchanged

| Location | Reason |
|----------|--------|
| ParameterSources.max_position | Input to compute effective limit |
| effective_max_position(fallback) | Needs static as fallback argument |
| Strategy inputs | Strategies internally call effective_max_position() |
| Logging static_max_pos | For debugging/comparison |

### Result

| Scenario | Before | After |
|----------|--------|-------|
| Position: -0.0885 BTC | Exceeds 0.05 → Reduce-Only ✗ | Within 0.283 → Normal ✓ |
| Utilization | 177% (wrong) | 31% (correct) |
| Consistency | Strategy ≠ Filter | Strategy = Filter |

---

## Architecture: Position Limits Flow (Updated)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    FIRST-PRINCIPLES CALCULATION                      │
│  calculate_dynamic_max_position_value(                              │
│      account_value, sigma, time_horizon, sigma_confidence,          │
│      &dynamic_risk_config                                            │
│  )                                                                   │
│                                                                      │
│  leverage_limit = account_value × max_leverage                       │
│  volatility_limit = (equity × risk_fraction) / (num_sigmas × σ × √T)│
│  max_position_VALUE = min(leverage_limit, volatility_limit)          │
│  max_position_SIZE = max_position_VALUE / mid_price                  │
└─────────────────────────────────────────────────────────────────────┘
                             │
                             ▼
             ┌───────────────────────────────┐
             │ MarketMaker.effective_max_pos │
             │ (cached, updated each cycle)  │
             └───────────────┬───────────────┘
                             │
     ┌───────────────────────┼───────────────────────┐
     │                       │                       │
     ▼                       ▼                       ▼
┌────────────┐      ┌────────────────┐      ┌───────────────┐
│ReduceOnly  │      │ MessageContext │      │ FillState     │
│ Config     │      │                │      │               │
└────────────┘      └────────────────┘      └───────────────┘
     │                       │                       │
     └───────────────────────┼───────────────────────┘
                             │
                             ▼
              ALL USE SAME EFFECTIVE LIMIT ✓
```

---

## Previous Session Work

### First-Principles Dynamic Position Limits

Position SIZE limit dynamically derived from VALUE limit:
```
dynamic_max_position = max_position_value / mid_price

where max_position_value = min(leverage_limit, volatility_limit)
- leverage_limit = account_value × max_leverage
- volatility_limit = (equity × risk_fraction) / (num_sigmas × σ × √T)
```

### Pending Exposure in Sizing Calculation

Subtract pending exposure from available sizing capacity to prevent breach.

### Phase 3-5: Component Wiring

- RecoveryManager: Stuck reduce-only recovery
- PositionReconciler: Position drift detection
- RejectionRateLimiter: Exponential backoff on rejections

---

## Open Items / Next Steps

1. **Time-based recovery escalation** - Reduce-only orders unfilled for too long should escalate to IOC
2. **Production testing** of harmonized position limits with real trading
3. **Tune DynamicRiskConfig** - risk_fraction, num_sigmas based on observed performance
4. **Clean up design doc** - DESIGN_POSITION_LIMIT_HARMONIZATION.md can be archived

---

## Testing Commands

```bash
# Run full test suite (404 tests)
cargo test

# Run with debug logging (shows effective limit updates)
RUST_LOG=hyperliquid_rust_sdk::market_maker=debug cargo run --bin market_maker -- --asset BTC

# Verify in logs:
# - "Effective max position updated from first principles" when limit changes
# - "effective_max_pos = X.XXXXXX" in quote inputs
# - Reduce-only warnings use effective limit
```

## Files Modified This Session

```
src/market_maker/mod.rs - Added effective_max_position field, updated 12 consumers
DESIGN_POSITION_LIMIT_HARMONIZATION.md - Created design document
```
