# Session Checkpoint - First-Principles Dynamic Position Limits

**Date**: 2025-12-30
**Session Focus**: Implementing first-principles dynamic `max_position` derived from equity/volatility instead of arbitrary static value
**Test Count**: 404 tests passing

---

## Completed Work (This Session)

### First-Principles Dynamic Position Limits

**Problem Solved**: The static `max_position = 0.05` was an arbitrary number that didn't scale with account equity or adapt to volatility. This caused:
1. Small accounts risking too much relative to equity
2. Large accounts being unnecessarily constrained
3. No risk reduction during high volatility periods

**Solution**: Position SIZE limit is now dynamically derived from VALUE limit:
```
dynamic_max_position = max_position_value / mid_price

where max_position_value = min(leverage_limit, volatility_limit)
- leverage_limit = account_value × max_leverage
- volatility_limit = (equity × risk_fraction) / (num_sigmas × σ × √T)
```

### Implementation Details

#### MarketParams Extension (`src/market_maker/strategy/market_params.rs`)
```rust
// New fields
pub dynamic_max_position: f64,  // SIZE limit derived from VALUE limit
pub dynamic_limit_valid: bool,  // true when margin state has been refreshed

// Helper method
pub fn effective_max_position(&self, static_fallback: f64) -> f64 {
    if self.dynamic_limit_valid && self.dynamic_max_position > 0.0 {
        self.dynamic_max_position
    } else {
        static_fallback  // Safe fallback during warmup
    }
}
```

#### ParameterSources Extension (`src/market_maker/strategy/params.rs`)
```rust
// New fields in ParameterSources
pub dynamic_max_position_value: f64,  // from kill_switch.max_position_value()
pub dynamic_limit_valid: bool,        // from margin_sizer.state().account_value > 0

// In ParameterAggregator::build():
dynamic_max_position: if sources.dynamic_limit_valid && sources.latest_mid > 0.0 {
    sources.dynamic_max_position_value / sources.latest_mid
} else {
    sources.max_position  // Fall back to static limit
},
dynamic_limit_valid: sources.dynamic_limit_valid,
```

#### Quote Cycle Wiring (`src/market_maker/mod.rs`)
```rust
// Get dynamic position VALUE limit from kill switch (first-principles derived)
let dynamic_max_position_value = self.safety.kill_switch.max_position_value();
// Margin state is valid if we've refreshed margin at least once
let dynamic_limit_valid = self.infra.margin_sizer.state().account_value > 0.0;

// Passed to ParameterSources and flows through to strategies
```

#### Strategy Updates (`src/market_maker/strategy/ladder_strat.rs`, `glft.rs`)
```rust
// FIRST PRINCIPLES: Use dynamic max_position derived from equity/volatility
let effective_max_position = market_params.effective_max_position(max_position);

// Used throughout for:
// - Gamma scaling (inventory utilization)
// - Inventory ratio calculation
// - Bid/ask sizing limits
// - Reduce-only mode detection
```

### Key Design Decisions

1. **Safe Fallback**: Uses static `config.max_position` during warmup (before margin state refreshed)
2. **Backward Compatible**: Function signatures unchanged - strategies receive both static and dynamic
3. **Automatic Scaling**:
   - Larger accounts → larger position limits
   - Higher volatility → tighter position limits
   - Exchange leverage caps → never exceeded
4. **Centralized Calculation**: Uses existing `calculate_dynamic_max_position_value()` in kill switch

### Files Modified This Session
```
src/market_maker/strategy/market_params.rs  - Added dynamic limit fields + helper method
src/market_maker/strategy/params.rs         - Extended ParameterSources + ParameterAggregator
src/market_maker/mod.rs                     - Wired dynamic limits into quote cycle
src/market_maker/strategy/ladder_strat.rs   - Updated to use effective_max_position
src/market_maker/strategy/glft.rs           - Updated to use effective_max_position
```

---

## Previous Session Work (Pending Exposure Fix)

### Pending Exposure in Sizing Calculation

**Problem**: Position could exceed `max_position` when multiple ladder levels filled between quote cycles.

**Solution**: Subtract pending exposure from available sizing capacity:
```rust
// Available capacity = max_position - current_position - pending_exposure_on_same_side
let (local_available_bids, local_available_asks) = if position >= 0.0 {
    let bid_limit = (max_position - position - pending_bids).max(0.0);
    let ask_limit = (position + max_position - pending_asks).max(0.0);
    (bid_limit, ask_limit)
} else {
    let bid_limit = (position.abs() + max_position - pending_bids).max(0.0);
    let ask_limit = (max_position - position.abs() - pending_asks).max(0.0);
    (bid_limit, ask_limit)
};
```

### Troubleshooting Reduce-Only Mode

**Root Causes Identified**:
1. Orders sized without considering pending exposure → multiple fills breach limits
2. Recovery only triggers on rejections, not unfilled passive orders
3. Position SIZE limit was arbitrary, not derived from equity

**Fixes Applied**:
1. ✅ Pending exposure subtracted from sizing (previous session)
2. ⏳ Time-based escalation for unfilled reduce orders (future work)
3. ✅ Dynamic max_position from first principles (this session)

---

## Previous Session Work (Phase 3-5 Wiring)

### Phase 3-5: Component Wiring into Main Orchestrator

#### InfraComponents Extension (`src/market_maker/core/components.rs`)
- **`recovery_manager: RecoveryManager`** - Phase 3 stuck reduce-only recovery
- **`reconciler: PositionReconciler`** - Phase 4 position drift detection
- **`rate_limiter: RejectionRateLimiter`** - Phase 5 exponential backoff on rejections

#### Event-Driven Reconciliation Wiring
```rust
// In start() main loop:
if let Some(trigger) = self.infra.reconciler.should_sync() {
    debug!(trigger = ?trigger, "Event-driven reconciliation triggered");
    if let Err(e) = self.safety_sync().await { ... }
}
```

#### Rate Limiter Integration
```rust
// Pre-flight check:
if self.infra.rate_limiter.should_skip(is_buy) {
    return Ok(());  // Skip due to rate limit backoff
}

// Recording results:
if result.oid > 0 {
    self.infra.rate_limiter.record_success(is_buy);
} else if let Some(ref err) = result.error {
    self.infra.rate_limiter.record_rejection(is_buy, err);
}
```

---

## Previous Session Work (Phase 1-2: Order State)

### TrackedOrder Enhancements
- **`cloid: Option<String>`** - Client order ID for correlation
- **`fill_value: f64`** - Accumulated fill value for average price
- **`last_fill_at: Option<Instant>`** - Timestamp of most recent fill
- **`average_fill_price()`** - Computed from fill_value / filled

### OrderManager Pending Exposure
- **`pending_exposure()`** → `(f64, f64)` - (bid_exposure, ask_exposure)
- **`worst_case_positions(current_position)`** → `(f64, f64)` - (min, max)

### RiskState Pending Exposure Fields
- **`worst_case_max_position: f64`** - Position if all bids fill
- **`worst_case_min_position: f64`** - Position if all asks fill
- **`worst_case_exceeds_limits()`** - Check method

---

## Performance Optimizations (Earlier Sessions)

### O(1) Liquidation Cascade Detection
- `IncrementalHawkes` struct using recursive weighted sum decay
- Key insight: `S' = S × exp(-β × Δt)` - all events decay uniformly
- **500x improvement**: O(n) 500 exp() → O(1) 1 exp()

### O(1) Stochastic Volatility Calibration
- `IncrementalVolStats` using Welford's algorithm
- **100% allocation reduction**: O(n²) + 4 Vec allocs → O(1) 0 allocs

---

## Architecture: Position Limits Flow

```
DynamicRiskConfig (first principles)
    │
    ├─ risk_fraction: 0.5 (50% of equity at risk in 5-sigma move)
    ├─ num_sigmas: 5.0 (99.99997% confidence)
    ├─ sigma_prior: 0.0002 (2bp/sec baseline)
    └─ max_leverage: 20.0 (exchange constraint)
          │
          ▼
calculate_dynamic_max_position_value()
    │
    ├─ leverage_limit = account_value × max_leverage
    └─ volatility_limit = (equity × risk_fraction) / (num_sigmas × σ × √T)
          │
          ▼
max_position_value = min(leverage, volatility)  [USD]
          │
          ▼
dynamic_max_position = max_position_value / mid_price  [contracts]
          │
          ▼
MarketParams.effective_max_position(static_fallback)
          │
          ▼
LadderStrategy / GLFTStrategy use for sizing
```

---

## Open Items / Next Steps

1. **Time-based recovery escalation** - Reduce-only orders unfilled for too long should escalate to IOC
2. **Production testing** of first-principles position limits with real equity
3. **Tune DynamicRiskConfig** - risk_fraction, num_sigmas based on observed performance
4. **Use average_fill_price** in P&L calculations for more accurate realized P&L
5. **Wire SafetyAuditor.check_pending_exposure_risk()** into periodic safety sync

## Testing Commands

```bash
# Run full test suite
cargo test

# Run with debug logging (shows dynamic vs static limits)
RUST_LOG=hyperliquid_rust_sdk::market_maker=debug cargo run --bin market_maker -- --asset BTC

# Check for regressions
cargo clippy -- -D warnings
```
